<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>每秒解析千兆字节的 JSON</title>
<meta name="author" content="Wong Ding Feng"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>
<style> .reveal { font-size: 32px; } .reveal .slides { margin: 0.5em; } </style>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">每秒解析千兆字节的 JSON</h1><h2 class="author">Wong Ding Feng</h2><p class="date">Created: 2025-02-11 Tue 13:54</p>
</section>
<section id="table-of-contents-section">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#/slide-1">1. 目标</a></li>
<li><a href="#/slide-2">2. 问题</a></li>
<li><a href="#/slide-3">3. 关于如何快速执行的想法?</a></li>
<li><a href="#/slide-4">4. 挑战</a></li>
<li><a href="#/slide-5">5. 关于 SIMD</a></li>
<li><a href="#/slide-6">6. Simdjson 实现</a></li>
<li><a href="#/slide-7">7. 阶段 1:结构和伪结构索引构建</a></li>
<li><a href="#/slide-8">8. 阶段 2:构建磁带</a></li>
<li><a href="#/slide-9">9. 代码库中的实际 c++ 代码实现和优化技巧</a></li>
<li><a href="#/slide-10">10. 谢谢您</a></li>
</ul>
</div>
</div>
</section>
<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> 目标</h2>
<aside class="notes">
<p>
Too many things to talk about
pick and choose some
</p>

</aside>
<ul>
<li>为什么 JSON 很慢?</li>
<li>位运算和 simd 简明入门</li>
<li>simdjson 架构</li>
<li>使用的 C++ 技术</li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> 问题</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> SBE vs JSON</h3>
<aside class="notes">
<p>
the reason why sbe is because we have the schema
</p>
<ul>
<li>we know how far to jump in the array to get data</li>
<li>there is no key to read and guess</li>
<li>sometimes we have the offset to jump forward</li>

</ul>
<p>
while for json we need to guess what the data means
there is also validation
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Binary Format (Schema: string[10], uint8)
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
&#9474; "John Doe"      &#9474; 42    &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;
  |               &#9492;&#9472; Age: Fixed 1 byte, parser knows to read exactly 1 byte
  &#9492;&#9472; Name: Fixed 10 bytes, parser knows to read exactly 10 bytes
                     (padded with spaces)
JSON Format
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
&#9474; {"name":"John Doe","age":42}     &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;
  |     |           |     &#9492;&#9472; Parser must scan until it finds closing brace
  |     |           &#9492;&#9472; Parser must scan for quotes and ":"
  |     &#9492;&#9472; Parser must scan for quotes and ":"
  &#9492;&#9472; Parser must scan character by character, looking for valid JSON tokens
</pre>
</div>
</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> 为什么 json 有趣?</h3>
<aside class="notes">
<ul>
<li>basically double the speed means you can parse 2x as much data</li>
<li>duplicating hardware for free</li>

</ul>

</aside>
<ul>
<li>大部分数据都是 json 格式</li>

</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parser</th>
<th scope="col" class="org-right">Skylake</th>
<th scope="col" class="org-right">Cannon Lake</th>
<th scope="col" class="org-left">speed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">simdjson</td>
<td class="org-right">1.4</td>
<td class="org-right">1.3</td>
<td class="org-left">fast</td>
</tr>

<tr>
<td class="org-left">RapidJSON</td>
<td class="org-right">0.56</td>
<td class="org-right">0.44</td>
<td class="org-left">slow</td>
</tr>

<tr>
<td class="org-left">sajson</td>
<td class="org-right">0.93</td>
<td class="org-right">0.84</td>
<td class="org-left">normal</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> 为什么你应该感兴趣</h3>
<aside class="notes">
<p>
this is the breakdown
can configure, if you remove utf-8 check
its even faster
</p>

</aside>
<ul>
<li>可配置,提高速度</li>

</ul>

<div id="org19656bc" class="figure">
<p><img src="https://arxiv.org/html/1902.08318v7/x1.png" alt="x1.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> 对比其他方案</h3>

<div id="org70c4e14" class="figure">
<p><img src="https://arxiv.org/html/1902.08318v7/x3.png" alt="x3.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-2-5">
<h3 id="2-5"><span class="section-number-3">2.5.</span> 按需 json</h3>

<div id="orgca627b3" class="figure">
<p><img src="https://arxiv.org/html/2312.17149v3/x1.png" alt="x1.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-2-6">
<h3 id="2-6"><span class="section-number-3">2.6.</span> 用法</h3>
<ul>
<li>读取
<ul>
<li>simdjson</li>
<li>simdjson: On Demand (stream)</li>
<li>fastjson2</li>

</ul></li>
<li>写入
<ul>
<li>rapidjson</li>
<li>fastjson2</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> 关于如何快速执行的想法?</h2>
<aside class="notes">
<p>
Look at how other people tried to speed it up
so what other ways can we speed it up?
json
</p>

</aside>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> 策略</h3>
<ul>
<li>取决于使用模式</li>

</ul>
</section>
<section id="slide-3-1-1">
<h4 id="3-1-1"><span class="section-number-4">3.1.1.</span> 查询密集型</h4>
<ul>
<li>创建一个数据库 (ElasticSearch, MongoDB, PostgresSQL)
<ul>
<li>创建一个 KV 存储</li>
<li>加载一次并查询它</li>

</ul></li>

</ul>
</section>
<section id="slide-3-1-2">
<h4 id="3-1-2"><span class="section-number-4">3.1.2.</span> 选择性解析</h4>
<aside class="notes">
<p>
The other opposite end is no parsing,
Skip the parsing as parsing takes time, NoDB, do a grep search and jump around detecting some structures and patterns in the data
There was a research paper talking about using JIT and speeding up the json query like a compiler
Mison is another implementation that uses simd to find important character locations like braces [] " : and the authors of simdjson learnt lots from them.
</p>

</aside>
<ul>
<li>选择性解析
<ul>
<li>NoDB
<ul>
<li>无需解析即可查询数据,无需加载到数据库中</li>
<li>像 grep 一样</li>

</ul></li>
<li>JIT 技术
<ul>
<li>查找模式和重复结构,编译用于特定查询的代码</li>
<li>像编译器一样</li>

</ul></li>
<li><span class="underline">Mison</span> (由 Microsoft 开发)
<ul>
<li>选择性解析,直接跳转到你想要的字段</li>
<li>使用 SIMD 查找结构性重要字符,例如 "</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> 什么是公平竞争?</h3>
<aside class="notes">
<p>
So there are many json implementations out there and to measure performance, we need to properly define what json means.
Most faster json parser implementations play cheat by just assuming the input is already valid.
assuming strings are only ascii when json RFC said UTF-8, dont validate numbers, selectively parsing.
simdjson is a complete parser following JSON RFC standards, fully validating the input yet being faster than all of them. assuming input is correct is dangerous because it just is wrong input and wrong output
</p>

</aside>
<ul>
<li>JSON 解析类型
<ul>
<li>非验证 JSON 解析器
<ul>
<li>假设输入是有效的</li>
<li>更容易</li>
<li>大多数选择性解析是非验证的</li>

</ul></li>
<li>验证 JSON 解析器
<ul>
<li>检查输入是否有效</li>
<li>没有假设或格式错误的输入
<ul>
<li>安全风险</li>
<li>它只是被解析的错误数字或字符串</li>

</ul></li>
<li>更难,更复杂</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> JSON 的正确定义</h3>
<aside class="notes">
<p>
This is the real EBNF grammar for json, its kinda complex so i wrote a simplified version below
</p>

</aside>
<div class="org-src-container">

<pre class="src src-ebnf">/* JSON EBNF Grammar Specification */
/* Root JSON structure */
<span style="color: #dcaeea;">json</span> = ws , (object | array) , ws <span style="color: #5B6268;">;</span>
/* Objects */
<span style="color: #dcaeea;">object</span> = <span style="color: #98be65;">"{"</span> , ws , [ members ] , ws , <span style="color: #98be65;">"}"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">members</span> = pair , { <span style="color: #98be65;">","</span> , ws , pair } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">pair</span> = string , ws , <span style="color: #98be65;">":"</span> , ws , value <span style="color: #5B6268;">;</span>
/* Arrays */
<span style="color: #dcaeea;">array</span> = <span style="color: #98be65;">"["</span> , ws , [ elements ] , ws , <span style="color: #98be65;">"]"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">elements</span> = value , { <span style="color: #98be65;">","</span> , ws , value } <span style="color: #5B6268;">;</span>
/* Values */
<span style="color: #dcaeea;">value</span> = string | number | object | array | <span style="color: #98be65;">"true"</span> | <span style="color: #98be65;">"false"</span> | <span style="color: #98be65;">"null"</span> <span style="color: #5B6268;">;</span>
/* Strings */
<span style="color: #dcaeea;">string</span> = '<span style="color: #98be65;">"' , { char | escape } , '"</span>' <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">char</span> = ? any Unicode character except <span style="color: #98be65;">" or \ or control characters ? ;</span>
<span style="color: #98be65;">escape = "</span>\" , ('<span style="color: #98be65;">"' | "</span>\" | <span style="color: #98be65;">"/"</span> | <span style="color: #98be65;">"b"</span> | <span style="color: #98be65;">"f"</span> | <span style="color: #98be65;">"n"</span> | <span style="color: #98be65;">"r"</span> | <span style="color: #98be65;">"t"</span> | unicode) <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">unicode</span> = <span style="color: #98be65;">"u"</span> , hexdigit , hexdigit , hexdigit , hexdigit <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">hexdigit</span> = digit | <span style="color: #98be65;">"A"</span> | <span style="color: #98be65;">"B"</span> | <span style="color: #98be65;">"C"</span> | <span style="color: #98be65;">"D"</span> | <span style="color: #98be65;">"E"</span> | <span style="color: #98be65;">"F"</span> | <span style="color: #98be65;">"a"</span> | <span style="color: #98be65;">"b"</span> | <span style="color: #98be65;">"c"</span> | <span style="color: #98be65;">"d"</span> | <span style="color: #98be65;">"e"</span> | <span style="color: #98be65;">"f"</span> <span style="color: #5B6268;">;</span>
/* Numbers */
<span style="color: #dcaeea;">number</span> = [ <span style="color: #98be65;">"-"</span> ] , (zero | integer) , [ fraction ] , [ exponent ] <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">integer</span> = nonzero , { digit } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">nonzero</span> = <span style="color: #98be65;">"1"</span> | <span style="color: #98be65;">"2"</span> | <span style="color: #98be65;">"3"</span> | <span style="color: #98be65;">"4"</span> | <span style="color: #98be65;">"5"</span> | <span style="color: #98be65;">"6"</span> | <span style="color: #98be65;">"7"</span> | <span style="color: #98be65;">"8"</span> | <span style="color: #98be65;">"9"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">digit</span> = <span style="color: #98be65;">"0"</span> | nonzero <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">zero</span> = <span style="color: #98be65;">"0"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">fraction</span> = <span style="color: #98be65;">"."</span> , digit , { digit } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">exponent</span> = (<span style="color: #98be65;">"E"</span> | <span style="color: #98be65;">"e"</span>) , [ <span style="color: #98be65;">"+"</span> | <span style="color: #98be65;">"-"</span> ] , digit , { digit } <span style="color: #5B6268;">;</span>
/* Whitespace */
<span style="color: #dcaeea;">ws</span> = { whitespace } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">whitespace</span> = <span style="color: #98be65;">" "</span> | <span style="color: #98be65;">"\t"</span> | <span style="color: #98be65;">"\n"</span> | <span style="color: #98be65;">"\r"</span> <span style="color: #5B6268;">;</span>
/* Comments and Explanation */
</pre>
</div>
</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> 强烈定义:bool、字符串、数字、null、对象和数组</h3>
<aside class="notes">
<p>
very simple, we just need to strongly define these 6 basic types
bool, string, number, null, object and array
write parsing rules to validate and check that they are valid
then understand what the data means
This sounds simple, but it is deceptively simple
</p>

</aside>
<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">JsonValue</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Primitive</span> <span style="color: #ECBE7B;">PrimitiveValue</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Container</span> <span style="color: #ECBE7B;">ContainerValue</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">6 primitives --------------------------</span>
<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">PrimitiveValue</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Boolean</span> <span style="color: #ECBE7B;">Bool</span>  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">true | false</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">String</span> <span style="color: #ECBE7B;">Text</span>   <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">"string"</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Number</span> <span style="color: #ECBE7B;">Double</span> <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">123, 1.23, 123e0, 123E0</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Null</span>          <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">null</span>
<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">ContainerValue</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Object</span> <span style="color: #ECBE7B;">Object</span> <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">{ "string", PrimitiveValue, ... }</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Array</span> <span style="color: #ECBE7B;">Array</span>   <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">[ PrimitiveValue, ... ]</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">END -----------------------------------</span>
<span style="color: #51afef;">newtype</span> <span style="color: #ECBE7B;">Object</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Object</span> [(<span style="color: #ECBE7B;">Text</span>, <span style="color: #ECBE7B;">JsonValue</span>)]
<span style="color: #51afef;">newtype</span> <span style="color: #ECBE7B;">Array</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Array</span> [<span style="color: #ECBE7B;">JsonValue</span>]
</pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> 强烈定义:bool、字符串、数字、null、对象和数组</h3>
<aside class="notes">
<p>
boolean, true, false and null are trivial
So first we start with the simplest sounding one of all, number, just integers right?, decimal perhaps? easy!
</p>

</aside>
</section>
<section id="slide-3-5-1">
<h4 id="3-5-1"><span class="section-number-4">3.5.1.</span> 数字限制和整数</h4>
<aside class="notes">
<p>
Lets take a look at limits.
Theres no strict definition for the limit of numbers, most use (2^53 - 1) because of the floating point representation
the authors of SIMDjson prefer 2^63 - 1
the first special case we have to deal with is negative numbers, we cant only detect 0 - 9, we have to detect - as well.
</p>

</aside>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">1. Integer Limits</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">INTEGER_EXAMPLES</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Maximum safe integer in JavaScript (2^53 - 1)</span>
<span style="color: #3dea43364a63;"> </span>   max_safe_integer: <span style="color: #da8548; font-weight: bold;">9007199254740991</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Minimum safe integer in JavaScript (-(2^53 - 1))</span>
<span style="color: #3dea43364a63;"> </span>   min_safe_integer: -<span style="color: #da8548; font-weight: bold;">9007199254740991</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Zero representations</span>
<span style="color: #3dea43364a63;"> </span>   zero: <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   negative_zero: -<span style="color: #da8548; font-weight: bold;">0</span>,  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">JSON preserves negative zero</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Common boundary values</span>
<span style="color: #3dea43364a63;"> </span>   max_32bit_int: <span style="color: #da8548; font-weight: bold;">2147483647</span>,
<span style="color: #3dea43364a63;"> </span>   min_32bit_int: -<span style="color: #da8548; font-weight: bold;">2147483648</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Integer examples</span>
<span style="color: #3dea43364a63;"> </span>   positive: <span style="color: #da8548; font-weight: bold;">42</span>,
<span style="color: #3dea43364a63;"> </span>   negative: -<span style="color: #da8548; font-weight: bold;">42</span>
};
</pre>
</div>
</section>
<section id="slide-3-5-2">
<h4 id="3-5-2"><span class="section-number-4">3.5.2.</span> 浮点数和科学计数法</h4>
<aside class="notes">
<p>
Floats, you see the e-308.
below you can see that both E and e are valid
some + and some - exponents
some without the + and - signs
what about the special case of 0.0e0!? how do we handle that?
these are all the details your validator needs to check for before declaring that this is a valid input
</p>

</aside>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">2. Floating Point Examples</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">FLOAT_EXAMPLES</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Precision examples (up to 15-17 significant digits)</span>
<span style="color: #3dea43364a63;"> </span>   high_precision: <span style="color: #da8548; font-weight: bold;">1.234567890123456</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Edge cases</span>
<span style="color: #3dea43364a63;"> </span>   very_small_positive: <span style="color: #da8548; font-weight: bold;">2</span>.2250738585072014e-<span style="color: #da8548; font-weight: bold;">308</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Near smallest possible double</span>
<span style="color: #3dea43364a63;"> </span>   very_large_positive: <span style="color: #da8548; font-weight: bold;">1</span>.7976931348623157e+<span style="color: #da8548; font-weight: bold;">308</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Near largest possible double</span>
};
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">3. Scientific Notation Examples</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">SCIENTIFIC_NOTATION</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Positive exponents</span>
<span style="color: #3dea43364a63;"> </span>   large_scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e+<span style="color: #da8548; font-weight: bold;">11</span>,
<span style="color: #3dea43364a63;"> </span>   very_large: <span style="color: #da8548; font-weight: bold;">1</span>.23E+<span style="color: #da8548; font-weight: bold;">308</span>,  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: Both 'e' and 'E' are valid</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Negative exponents</span>
<span style="color: #3dea43364a63;"> </span>   small_scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e-<span style="color: #da8548; font-weight: bold;">11</span>,
<span style="color: #3dea43364a63;"> </span>   very_small: <span style="color: #da8548; font-weight: bold;">1</span>.23E-<span style="color: #da8548; font-weight: bold;">308</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Zero with exponent</span>
<span style="color: #3dea43364a63;"> </span>   zero_scientific: <span style="color: #da8548; font-weight: bold;">0</span>.0e0,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Various representations</span>
<span style="color: #3dea43364a63;"> </span>   alternative_forms: {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   standard: <span style="color: #da8548; font-weight: bold;">1230000000</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e9,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   another_form: 123e7
<span style="color: #3dea43364a63;"> </span>   }
};
</pre>
</div>
</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> 字符串:处理转义引号和 UTF-8</h3>
<aside class="notes">
<p>
next we have string, many implementations just assume ascii
</p>
<ul>
<li>simple 128 possibilities</li>
<li>mostly correct data usually just ascii</li>

</ul>
<p>
but json RFC says it must be UTF-8
the last important thing to take note of is escaped \", we need to detect them properly to get the correct json, everything is done in simd.
</p>

</aside>
<ul>
<li>一些惰性解析器为了简单起见,假定为 ascii
<ul>
<li>128 种可能性,只有 8 位</li>
<li>假设输入没有日语、中文或奇怪的字符</li>

</ul></li>
<li>RFC 标准说字符串是 UTF-8</li>
<li>转义双引号 &ldquo;Tom said: \&rdquo;hello\&ldquo;.&rdquo;
<ul>
<li>Tom said: &ldquo;hello&rdquo;.</li>
<li>&rsquo;\&rsquo; 的数量
<ul>
<li>奇数 -&gt; 转义, &ldquo;\&rdquo;&ldquo; -&gt; &rdquo;</li>
<li>偶数 -&gt; 未转义, &ldquo;\\&rdquo; -&gt; \</li>

</ul></li>

</ul></li>
<li>在 " 之外,只能有 4 种空格符
<ul>
<li>&ldquo; &rdquo; | &ldquo;\t&rdquo; | &ldquo;\r&rdquo; | &ldquo;\n&rdquo;</li>

</ul></li>

</ul>
</section>
<section id="slide-3-6-1">
<h4 id="3-6-1"><span class="section-number-4">3.6.1.</span> ASCII 码</h4>
<aside class="notes">
<p>
This is just simply the ascii code table, quite sure we are all very familiar with it 0x30 - 0x39 is digits 0-9 lets move on
</p>

</aside>
<ul>
<li>代码点 0x00 - 0xEF 127 种可能性</li>

</ul>

<div id="org387e3ca" class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/USASCII_code_chart.svg/1280px-USASCII_code_chart.svg.png" alt="1280px-USASCII_code_chart.svg.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-3-6-2">
<h4 id="3-6-2"><span class="section-number-4">3.6.2.</span> UTF-8</h4>
<aside class="notes">
<p>
if it starts with the first bit being 0, it is ASCII
else if it is 1, it must conform to UTF-8 standards
this is why utf-8 validation is not straight forward
but the authors fugired out a way to do it with simd
it was able to detect this pattern in simd
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data
Two bytes:
110xxxxx 10xxxxxx           (values 128-2047)
First byte starts with 110
Three bytes:
1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
First byte starts with 1110
Four bytes:
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
First byte starts with 11110
</pre>
</div>
</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> 需求总结</h3>
<ul>
<li>数字
<ul>
<li>负数 + -</li>
<li>浮点数 1.23</li>

</ul></li>
<li>字符串
<ul>
<li>utf-8</li>
<li>转义引号 \&ldquo; | \\&rdquo;</li>

</ul></li>
<li>结构良好
<ul>
<li>有效的空格</li>
<li>有效的括号 {}, []</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> 挑战</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> 为其编写解析器</h3>
<aside class="notes">
<p>
Im not sure how many of us here has written a recursive descent parser but normally
how one would write a parser is that
one would just scan the string from left to right until it can determine what to do with the input
this requires many if else checks to see when to stop, when to look back, when to decide that what I am seeing is an object, string, array &#x2026;
the problem is that if statements cause a miss predicted branch, this is very costly to computers
if the branching is very predictable, like taking true all the time, there is no cost, usually the cpu will just
assume the previous branch was taken and follow that, then the cost is 1 cycle
if we need to stop and recorrect the branch it will take at least 15 cycles.
Can you do it without branches? thats what the SIMDjson team was working on.
</p>

</aside>
<ul>
<li>递归下降类型解析器</li>
<li>需要许多 if else,是否可以在没有任何分支的情况下完成?</li>

</ul>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">peek_token_type</span>(json_str, index):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">char</span> = json_str[index]
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Skip whitespace</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> index &lt; <span style="color: #c678dd;">len</span>(json_str) <span style="color: #51afef;">and</span> is_whitespace(char):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">index</span> += <span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">char</span> = json_str[index]
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check data type based on first character</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> char == <span style="color: #98be65;">'{'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'object'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'['</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'array'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'"'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'string'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> is_digit(char):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'number'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char <span style="color: #98be65;">'t'</span> <span style="color: #51afef;">or</span> char <span style="color: #98be65;">'f'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'boolean'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'n'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'null'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">else</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">raise</span> <span style="color: #ECBE7B;">ValueError</span>(f<span style="color: #98be65;">"Invalid JSON character at position </span>{index}<span style="color: #98be65;">: </span>{char}<span style="color: #98be65;">"</span>)
</pre>
</div>
</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> 鉴于挑战,如何快速完成?</h3>
<aside class="notes">
<p>
mison already implemented some of these but not everything
</p>

</aside>
<ul>
<li>SIMD,一次处理超过 8 个字节。
<ul>
<li>无分支代码,没有 if 语句。CPU 错误预测分支。
<ul>
<li>正确,0-1 个周期</li>
<li>分支错误,20 个周期</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> 关于 SIMD</h2>
<p>
simd 如何融入所有这些?
</p>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> 什么是 simd</h3>
<aside class="notes">
<p>
usually when we program, we work with one variable 64 bytes
this is the sisd model
one data one instruction
just imagine that instead of working with one number
we work with 8 in parallel instead 256, 512 bytes
this is the simd on the bottom left
</p>

</aside>

<div id="org1cd8980" class="figure">
<p><img src="https://pep-root6.github.io/docs/analysis/simd.png" alt="simd.png" />
</p>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> SIMD 示例</h3>
<aside class="notes">
<p>
here is an example
its just adding 2 arrays together with one instruction
normally we need a for loop to do this
but using simd we can do it in one step
</p>

</aside>
<pre class="example" id="orgb213f8a">
同时添加 4 个数字:
标量:
A: [5] + [3] = [8]     步骤 1
B: [7] + [2] = [9]     步骤 2
C: [4] + [6] = [10]    步骤 3
D: [1] + [8] = [9]     步骤 4
SIMD:
[5|7|4|1] +
[3|2|6|8] =   步骤 1
[8|9|10|9]    完成!
</pre>
</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> CPU</h3>
<div class="org-src-container">

<pre class="src src-text">Year:         2010          2013          2019
Architecture: Westmere  -&gt;  Haswell   -&gt;  Ice Lake
Process:      32nm          22nm          10nm
Vector ISA:   SSE2      -&gt;  AVX2      -&gt;  AVX512
Vec Width:    128-bit       256-bit       512-bit
             (16 bytes)    (32 bytes)    (64 bytes)
</pre>
</div>
<ul>
<li>流式 SIMD 扩展
<ul>
<li>XMM0-XMM15</li>

</ul></li>
<li>高级向量扩展 2
<ul>
<li>YMM0-YMM15</li>

</ul></li>
<li>高级向量扩展 512
<ul>
<li>ZMM0-ZMM15</li>

</ul></li>

</ul>
</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> SIMD 代码并没有那么可怕</h3>
<p>
Westmere 使用 128 位 SSE 指令     (_mm_shuffle_epi8)
Haswell  使用 256 位 AVX2 指令    (_mm256_shuffle_epi8)
Ice Lake 使用 512 位 AVX-512 指令 (_mm512_shuffle_epi8)
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Westmere</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">2</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">3</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Haswell (2 x 256-bit chunks)</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Ice Lake (1 x 512-bit chunk)</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm512_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
</pre>
</div>
</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> 一些 simd 示例</h3>
<aside class="notes">
<p>
add
have different types like 8,16,32,64
subtract
multiply
or and xor bitwise
sll srl
</p>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" style="font-size: 16px;">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Intrinsic Function</th>
<th scope="col" class="org-left">Instruction</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">_mm256_add_epi8(a, b)</td>
<td class="org-left">VPADDB</td>
<td class="org-left">Add packed 8-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_add_epi16(a, b)</td>
<td class="org-left">VPADDW</td>
<td class="org-left">Add packed 16-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_add_epi32(a, b)</td>
<td class="org-left">VPADDD</td>
<td class="org-left">Add packed 32-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_add_epi64(a, b)</td>
<td class="org-left">VPADDQ</td>
<td class="org-left">Add packed 64-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_sub_epi64(a, b)</td>
<td class="org-left">VPSUBQ</td>
<td class="org-left">Subtract packed 64-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_mullo_epi32(a, b)</td>
<td class="org-left">VPMULLD</td>
<td class="org-left">Multiply packed 32-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_mulhi_epi16(a, b)</td>
<td class="org-left">VPMULHW</td>
<td class="org-left">Multiply packed 16-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_and_si256(a, b)</td>
<td class="org-left">VPAND</td>
<td class="org-left">Bitwise AND of 256 bits</td>
</tr>

<tr>
<td class="org-left">_mm256_or_si256(a, b)</td>
<td class="org-left">VPOR</td>
<td class="org-left">Bitwise OR of 256 bits</td>
</tr>

<tr>
<td class="org-left">_mm256_xor_si256(a, b)</td>
<td class="org-left">VPXOR</td>
<td class="org-left">Bitwise XOR of 256 bits</td>
</tr>

<tr>
<td class="org-left">_mm256_andnot_si256(a, b)</td>
<td class="org-left">VPANDN</td>
<td class="org-left">Bitwise AND NOT of 256 bits</td>
</tr>

<tr>
<td class="org-left">_mm256_slli_epi64(a, imm8)</td>
<td class="org-left">VPSLLQ</td>
<td class="org-left">Shift packed 64-bit</td>
</tr>

<tr>
<td class="org-left">_mm256_srli_epi64(a, imm8)</td>
<td class="org-left">VPSRLQ</td>
<td class="org-left">Shift packed 64-bit</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> SIMD 的闪光点</h3>
<aside class="notes">
<ul>
<li>Regular, predictable data patterns</li>
<li>Simple mathematical operations</li>
<li>Continuous blocks of memory</li>
<li>Identical operations on multiple data points</li>
<li>High throughput</li>

</ul>

</aside>
<ul>
<li>规则的,可预测的数据模式</li>
<li>简单的数学运算</li>
<li>连续的内存块</li>
<li>多个数据点上的相同操作</li>
<li>高吞吐量</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">Perfect for SIMD:
[1|2|3|4] &#215; 2  = [2 |4 |6 |8 ] &#10003;
[R|G|B|A] + 10 = [R'|G'|B'|A'] &#10003;
</pre>
</div>
</section>
<section id="slide-5-7">
<h3 id="5-7"><span class="section-number-3">5.7.</span> SIMD 的阿喀琉斯之踵:分支</h3>
<aside class="notes">
<p>
is harder to do simd
but if we can remove the if statements
it is possible to do simd
we do it with branchless, simd can be applied to it
</p>

</aside>
<ul>
<li>如果类似解析中的逻辑很复杂,则无法进行 simd</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'{'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"object"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'['</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"array"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'"'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"string"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>is_digit<span style="color: #c678dd;">(</span>char_at<span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"number"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at <span style="color: #98be65;">'t'</span> || char_at <span style="color: #98be65;">'f'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"boolean"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'n'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"null"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">throw</span> <span style="color: #a9a1e1;">std</span>::invalid_argument<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">"Invalid JSON character at position "</span> +
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::to_string<span style="color: #98be65;">(</span>index<span style="color: #98be65;">)</span> +
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">": "</span> + char_at
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-5-7-1">
<h4 id="5-7-1"><span class="section-number-4">5.7.1.</span> 正确的分支预测</h4>
<aside class="notes">
<p>
when there is a branch, branch prediction usually use the last 2 times rule
and assumes that that branch will be taken
this is the cpu instruction pipeline
there are 5 steps in the cpu
fetch, decode, execue, memory, write
so they pipeline so that every time, all stages are busy
if they guess the branch correctly, there is actually no cost
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">IF = Instruction Fetch
ID = Instruction Decode
EX = Execute
MEM = Memory Access
WB = Write Back
Time &#8594;
1  2  3  4  5  6  7  8  9
IF ID EX ME WB          | Instruction 1 (branch)
   IF ID EX ME WB       | Instruction 2 (correctly predicted)
      IF ID EX ME WB    | Instruction 3
         IF ID EX ME WB | Instruction 4
</pre>
</div>
</section>
<section id="slide-5-7-2">
<h4 id="5-7-2"><span class="section-number-4">5.7.2.</span> 分支预测错误</h4>
<aside class="notes">
<p>
only at time 4 it realize that it is wrong and need to go to the other branch
so it has to flush
</p>

</aside>
<ul>
<li>示例成本 3 个周期,但实际 cpu 成本 7-15 个周期</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">Time &#8594;      FLUSH
1  2  3  4  5  6  7  8  9 10 11 12 13
IF ID EX ME WB                | Instruction 1 (branch)
   IF ID EX -- -- --          | Instruction 2 (wrong path)
      IF ID EX -- -- --          | Instruction 3 (wrong path)
         IF ID -- -- --          | Instruction 4 (wrong path)
            IF ID EX ME WB    | Correct Instruction 2
               IF ID EX ME WB | Correct Instruction 3
</pre>
</div>
</section>
<section id="slide-5-7-3">
<h4 id="5-7-3"><span class="section-number-4">5.7.3.</span> 算术布尔值</h4>
<aside class="notes">
<p>
LLVM optimization is very complex
there are many rules for -o2 -o3
different versions
gcc vs clang llvm
these are just examples
</p>

</aside>
<ul>
<li>实际上,当您执行 -o2 和 -o3 时,LLVM 会为您执行此操作</li>

</ul>
<div class="org-src-container">

<pre style="font-size: 16px;"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 1: Arithmetic with booleans</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">condition</span> = <span style="color: #a9a1e1;">true</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">20</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branched version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>condition<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = a;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = b;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version 1</span>
<span style="color: #3dea43364a63;"> </span>   x = condition _a + <span style="color: #51afef;">(</span><span style="color: #51afef; font-weight: bold;">!</span>condition<span style="color: #51afef;">)</span><span style="color: #ECBE7B;">_</span> <span style="color: #dcaeea;">b</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true _10 + (!true)_ 20</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1 _10 + 0_ 20</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 + 0 = 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version 2</span>
<span style="color: #3dea43364a63;"> </span>   x = b + <span style="color: #51afef;">(</span>a - b<span style="color: #51afef;">)</span> * condition;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 + (10 - 20) * true</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 + (-10) * 1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 - 10 = 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
</pre>
</div>
</section>
<section id="slide-5-7-4">
<h4 id="5-7-4"><span class="section-number-4">5.7.4.</span> 选择索引</h4>
<ul>
<li>实际上,当您执行 -o2 和 -o3 时,LLVM 会为您执行此操作</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 2: Tuple indexing</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">condition</span> = <span style="color: #a9a1e1;">true</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">20</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branched version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>condition<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = a;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = b;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">array</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span>, <span style="color: #da8548; font-weight: bold;">2</span><span style="color: #51afef;">&gt;</span> <span style="color: #dcaeea;">values</span> = <span style="color: #51afef;">{</span>b, a<span style="color: #51afef;">}</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: array order is {b, a} to match Python's (b, a)</span>
<span style="color: #3dea43364a63;"> </span>   x = values<span style="color: #51afef;">[</span>condition<span style="color: #51afef;">]</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{20, 10}[true]</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{20, 10}[1]     // true converts to 1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
</pre>
</div>
</section>
<section id="slide-5-7-5">
<h4 id="5-7-5"><span class="section-number-4">5.7.5.</span> 如果 LLVM 为您执行此操作,那有什么意义?</h4>
<aside class="notes">
<p>
LLVM only good at small cases.
For larger complex patterns like JSON.
you must give it as much information as possible to do it.
if you have an array and if it doesn&rsquo;t know that this is 512 bytes, it cannot do simd optimizations
The authors noticed several patterns in the data.
Exploited them and made all operations into SIMD.
Also by batching operations together like maybe do 1 type of operation over the entire string
We can basically almost use SIMD for the entire parsing instead of small minor optimizations.
</p>

</aside>
<ul>
<li>LLVM 尽力而为,但它找不到所有内容
<ul>
<li>擅长小案例</li>

</ul></li>
<li>一些较大的复杂模式
<ul>
<li>人工模式识别</li>
<li>批处理操作可以使用 simd</li>

</ul></li>

</ul>
</section>
<section id="slide-5-8">
<h3 id="5-8"><span class="section-number-3">5.8.</span> 编写无分支代码(按位运算)</h3>
<div class="outline-text-3" id="text-5-8">
</div>
</section>
<section id="slide-5-8-1">
<h4 id="5-8-1"><span class="section-number-4">5.8.1.</span> 棘手的内存布局</h4>
<div class="org-src-container">

<pre class="src src-text">number = 305,419,896
number &lt;&lt; 1 # shift left logical
Number: 305,419,896
Hex: 0x12345678
Physical Memory Layout (lowest bit &#8594; highest bit)
   Addr Low                           Addr High
     0x1200                              0x1203
        |                                 |
        v                                 v
Before: 00011110 01101010 00110100 00010010
           &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;
After:  00001111 00110101 00010110 00100100
        &#8593;
        0 enters
Decimal: 610,839,792
Hexadecimal: 0x2468ACF0
</pre>
</div>
<aside class="notes">
<p>
need to know some low level operations to explain all the SIMD things later
</p>

</aside>
</section>
<section id="slide-5-8-2">
<h4 id="5-8-2"><span class="section-number-4">5.8.2.</span> 掩码</h4>
<pre class="example">
a = 00001111
b = 11111100
and_op = a &amp; b
and_op = 00001100
or_op = a | b
or_op = 11111111
xor_or = a ^ b
xor_or = 11110011
</pre>
</section>
<section id="slide-5-8-3">
<h4 id="5-8-3"><span class="section-number-4">5.8.3.</span> 取消设置最右边的位(blsr)</h4>
<pre class="example">
s = s &amp; (s-1)
a =     00101100
b =     (a - 1)
a =     00101100
b =     00101011
a &amp; b = 00101000
// rightmost bit is unset
</pre>
<ul>
<li>通用 cpu 操作,编译器优化为 <code>blsr</code></li>

</ul>
</section>
<section id="slide-5-9">
<h3 id="5-9"><span class="section-number-3">5.9.</span> LLVM 编译器</h3>
<aside class="notes">
<p>
One of the things to do to write fast code is know how the LLVM compiler optimizes your code
There are many many optimizations available for us to use, so I will not go through them,
I&rsquo;ll just talk abit about how optimizations even work in the first place.
</p>

</aside>

<div id="org8cab175" class="figure">
<p><img src="https://llvm.org/img/LLVMWyvernSmall.png" alt="LLVMWyvernSmall.png" />
</p>
</div>
</section>
<section id="slide-5-9-1">
<h4 id="5-9-1"><span class="section-number-4">5.9.1.</span> LLVM</h4>
<aside class="notes">
<p>
LLVM is split up into 3 parts,
Frontend, middle-end and backend
the front end will read our c++ source code and output something called a Intermediate Representation
Then the IR will be optimized then the backend will target different cpu platforms like X86, ARM and PowerPC
Thats all LLVM is, its not that difficult
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">      Frontend         Middle-end              Backend
             &#8595;                &#8595;              &#8601;         &#8600;
Source Code &#8594; LLVM IR &#8594; [Optimized IR] &#8594; [Assembly] &#8594; Machine Code
                                     &#8600;________________&#8599;
                                     (direct path option)
</pre>
</div>
</section>
<section id="slide-5-9-2">
<h4 id="5-9-2"><span class="section-number-4">5.9.2.</span> 没有 LLVM IR</h4>
<aside class="notes">
<p>
Why do we need to have this IR
Every new language we add we need to write compilers to target all the outputs
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Without LLVM IR (n*m: 3 languages &#215; 3 targets = 9 compilers)
---------------------------------------------------------
C++   ----&#8594;  x86_64
      \---&#8594;  AMD
       \--&#8594;  ARM
Rust  ----&#8594;  x86_64
      \---&#8594;  AMD
       \--&#8594;  ARM
Haskell --&#8594;  x86_64
        \-&#8594;  AMD
         \&#8594;  ARM
Each arrow represents a separate compiler frontend+backend (9 total)
</pre>
</div>
</section>
<section id="slide-5-9-3">
<h4 id="5-9-3"><span class="section-number-4">5.9.3.</span> 使用 LLVM IR</h4>
<aside class="notes">
<p>
We just write one compiler to target the IR then it can just generate the output for each architecture
Any optimizations and improvements to the compiler on the right side, we get it for free on the left side.
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">With LLVM IR (n+m: 3 frontends + 3 backends = 6 components)
--------------------------------------------------------
            &#9581;&#8594; x86_64
C++    &#9582;    &#9474;
       &#8595;    &#9474;
Rust   &#9473;&#9473;&#8594; IR &#9473;&#9473;&#8594; AMD
       &#8593;    &#9474;
Haskell&#9583;    &#9474;
            &#9584;&#8594; ARM
            &#9482;
            &#8595;
    Shared Optimizations
    - Dead code elimination
    - Loop vectorization
    - Constant propagation
    - And many more...
</pre>
</div>
</section>
<section id="slide-5-9-4">
<h4 id="5-9-4"><span class="section-number-4">5.9.4.</span> 中间表示示例(IR)</h4>
<aside class="notes">
<p>
Lets talk about an example code here very simple for loop
sum += i*4
return
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">example2</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   sum += i * <span style="color: #da8548; font-weight: bold;">4</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Multiplication in loop</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> sum;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-5-9-5">
<h4 id="5-9-5"><span class="section-number-4">5.9.5.</span> 未优化 IR -O0</h4>
<aside class="notes">
<p>
If we compile with -O0, optimization level 0, no optimization
This is the IR
its this cpu agnostic code that has as much information retained from the original source code as possible
this is because to optimize, the compiler has to know what data types its dealing with
and then it can draw a computation graph to eliminate useless computation
</p>

</aside>
<div class="org-src-container">

<pre class="src src-llvm-ts">define dso_local i32 @_Z8example2i(i32 %<span style="color: #da8548; font-weight: bold;">0</span>) {
entry:
  %n = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  %sum = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  %i = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 %<span style="color: #da8548; font-weight: bold;">0</span>, ptr %n, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 <span style="color: #da8548; font-weight: bold;">0</span>, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 <span style="color: #da8548; font-weight: bold;">0</span>, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.cond
for.cond:
  %<span style="color: #da8548; font-weight: bold;">1</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %<span style="color: #da8548; font-weight: bold;">2</span> = load i32, ptr %n, align <span style="color: #da8548; font-weight: bold;">4</span>
  %cmp = icmp slt i32 %<span style="color: #da8548; font-weight: bold;">1</span>, %<span style="color: #da8548; font-weight: bold;">2</span>
  br i1 %cmp, label %for.body, label %for.end
for.body:
  %<span style="color: #da8548; font-weight: bold;">3</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %mul = mul nsw i32 %<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>
  %<span style="color: #da8548; font-weight: bold;">4</span> = load i32, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  %add = add nsw i32 %<span style="color: #da8548; font-weight: bold;">4</span>, %mul
  store i32 %add, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.inc
for.inc:
  %<span style="color: #da8548; font-weight: bold;">5</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %inc = add nsw i32 %<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">1</span>
  store i32 %inc, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.cond
for.end:
  %<span style="color: #da8548; font-weight: bold;">6</span> = load i32, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  ret i32 %<span style="color: #da8548; font-weight: bold;">6</span>
}
</pre>
</div>
</section>
<section id="slide-5-9-6">
<h4 id="5-9-6"><span class="section-number-4">5.9.6.</span> 未优化 IR -O0 图</h4>
<aside class="notes">
<p>
this is the computation graph of the IR in front
</p>

</aside>

<div id="orge229b25" class="figure">
<p><img src="attachments/unoptimized-ir.png" alt="unoptimized-ir.png" />
</p>
</div>
</section>
<section id="slide-5-9-7">
<h4 id="5-9-7"><span class="section-number-4">5.9.7.</span> 优化 IR -O2</h4>
<aside class="notes">
<p>
this is compiled with -O2
</p>

</aside>
<div class="org-src-container">

<pre class="src src-llvm-ts">define dso_local i32 @_Z8example2i(i32 %<span style="color: #da8548; font-weight: bold;">0</span>) local_unnamed_addr #<span style="color: #da8548; font-weight: bold;">0</span> {
entry:
  %cmp6 = icmp sgt i32 %<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>
  br i1 %cmp6, label %for.body.preheader, label %for.end
for.body.preheader:
  %<span style="color: #da8548; font-weight: bold;">1</span> = add i32 %<span style="color: #da8548; font-weight: bold;">0</span>, -<span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">2</span> = mul i32 %<span style="color: #da8548; font-weight: bold;">0</span>, %<span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">3</span> = lshr i32 %<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">4</span> = mul i32 %<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.end
for.end:
  %sum.0.lcssa = phi i32 [ <span style="color: #da8548; font-weight: bold;">0</span>, %entry ], [ %<span style="color: #da8548; font-weight: bold;">4</span>, %for.body.preheader ]
  ret i32 %sum.0.lcssa
}
</pre>
</div>
</section>
<section id="slide-5-9-8">
<h4 id="5-9-8"><span class="section-number-4">5.9.8.</span> 优化 IR -O2 图</h4>
<aside class="notes">
<p>
with deadcode eliminated
</p>

</aside>

<div id="org8fdf84f" class="figure">
<p><img src="attachments/optimized-ir.png" alt="optimized-ir.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Simdjson 实现</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> Simdjson 架构概述</h3>
<aside class="notes">
<p>
indexing structure, basically to find the places where the data is at
object, array, strings
validate UTF-8
</p>
<ol>
<li>Stage 1: Structural Index Creation (find location of important markers)
<ol>
<li>Find structural characters ({,},[,],",,:)</li>
<li>Locate whitespace</li>
<li>Identify string boundaries</li>
<li>Validate UTF-8 encoding</li>

</ol></li>

</ol>
<p>
generating output tape to navigate
parsing
</p>
<ol>
<li>Stage 2: Parsing &amp; Tape Building
<ol>
<li>Validate document structure</li>
<li>Build navigable tape representation
<ol>
<li>Parse atomic values (strings, numbers, true/false/null)</li>
<li>Convert numbers to machine formats</li>
<li>Normalize strings to UTF-8</li>

</ol></li>

</ol></li>

</ol>

</aside>
<ol>
<li>阶段 1:结构索引创建(查找重要标记的位置)
<ol>
<li>查找结构字符 ({,},[,],",,:)</li>
<li>定位空格</li>
<li>识别字符串边界</li>
<li>验证 UTF-8 编码</li>

</ol></li>
<li>阶段 2:解析和磁带构建
<ol>
<li>验证文档结构</li>
<li>构建可导航磁带表示
<ol>
<li>解析原子值(字符串,数字,true/false/null)</li>
<li>将数字转换为计算机格式</li>
<li>将字符串规范化为 UTF-8</li>

</ol></li>

</ol></li>

</ol>
</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> simdjson 图</h3>
<aside class="notes">
<p>
the actual way it is processed is
reading in the input string
convert to bytes
code interface is working on 512 byte chunks
if there are smaller divisions, it will split it up interally inside and work on those
find the important locations called structural locations as a bitmask
bitmask convert to index
parse the true false null
output the final tape
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">    JSON INPUT STRING
   "{"name": "value"}"
            &#11015;
     512-BYTE CHUNKS -&gt; 512x1,256x2,128x4
   &#9556;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9559;
   &#9553;"{"name": "val...&#9553;
   &#9562;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9565;
            &#11015;
         STAGE 1
  (Bitmap Generation &amp;   find: ([, {, ], }, :, ,)
   Index Extraction)     escaped characters and quoted regions
            &#11015;            Validate UTF-8
       INDEX ARRAY
      [0,3,5,7,...]
            &#11015;
         STAGE 2         parse number, int, float, 1e10, true, false, null, string
   (Parse &amp; Build Tape)  build tape to navigate
            &#11015;
       FINAL TAPE
[.........................]
</pre>
</div>
</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> 阶段 1:结构和伪结构索引构建</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</section>
<section id="slide-6-3-1">
<h4 id="6-3-1"><span class="section-number-4">6.3.1.</span> 输入与输出</h4>
<ul>
<li>输入:原始 JSON 字节</li>
<li>输出:
<ul>
<li>结构字符的位掩码</li>
<li>标记结构元素的整数索引数组</li>

</ul></li>

</ul>
</section>
<section id="slide-6-3-2">
<h4 id="6-3-2"><span class="section-number-4">6.3.2.</span> 主要职责</h4>
<ol>
<li>字符编码验证 (UTF-8)</li>
<li>定位结构字符 ([, {, ], }, :, ,)</li>
<li>识别字符串边界
<ol>
<li>处理转义字符和引用区域</li>

</ol></li>
<li>查找伪结构字符(如数字,true,false,null 等原子)</li>

</ol>
</section>
<section id="slide-6-4">
<h3 id="6-4"><span class="section-number-3">6.4.</span> 阶段 2:结构化导航</h3>
<div class="outline-text-3" id="text-6-4">
</div>
</section>
<section id="slide-6-4-1">
<h4 id="6-4-1"><span class="section-number-4">6.4.1.</span> 输入与输出</h4>
<ul>
<li>输入:来自阶段 1 的结构索引数组</li>
<li>输出:在“磁带”(数组)上解析的 JSON 结构</li>
<li>目的:构建 JSON 文档的可导航表示</li>

</ul>
</section>
<section id="slide-6-4-2">
<h4 id="6-4-2"><span class="section-number-4">6.4.2.</span> 主要职责</h4>
<ol>
<li>解析字符串并转换为 UTF-8</li>
<li>将数字转换为 64 位整数或双精度数</li>
<li>验证结构规则(匹配括号,正确序列)</li>
<li>构建可导航的磁带结构</li>

</ol>
</section>
<section id="slide-6-4-3">
<h4 id="6-4-3"><span class="section-number-4">6.4.3.</span> 磁带格式</h4>
<ul>
<li>每个节点 64 位字</li>
<li>不同类型的特殊编码:
<ul>
<li>原子(null,true,false): n/t/f × 2^56</li>
<li>数字:两个 64 位字</li>
<li>数组/对象:具有导航指针的开始/结束标记</li>
<li>字符串:指向字符串缓冲区的指针</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> 阶段 1:结构和伪结构索引构建</h2>
<aside class="notes">
<p>
this is how the high level overview of this stage, the c++ code looks like
the important thing is this _mm256_shuffle_epi8 == VPSHUFB
it is basically a small nibble level lookup table with 16 slots
i will talk more about this later
</p>

</aside>
<p>
_mm256_shuffle_epi8 == VPSHUFB
</p>
<div class="org-src-container">

<pre style="font-size: 16px;"><span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">_mm256_shuffle_epi8 == VPSHUFB</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">whitespace_table</span> = <span style="color: #a9a1e1;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>::repeat_16<span style="color: #51afef;">(</span><span style="color: #98be65;">' '</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">17</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">113</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #98be65;">'\t'</span>, <span style="color: #98be65;">'\n'</span>, <span style="color: #da8548; font-weight: bold;">112</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #98be65;">'\r'</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">op_table</span> = <span style="color: #a9a1e1;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>::repeat_16<span style="color: #51afef;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #98be65;">':'</span>, <span style="color: #98be65;">'{'</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">: = 3A, [ = 5B, { = 7B</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">','</span>, <span style="color: #98be65;">'}'</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">, = 2C, ] = 5D, } = 7D</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Turn [ and ] into { and }</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8x64</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #dcaeea;">curlified</span><span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   in.chunks<span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">]</span> | <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">20</span>,
<span style="color: #3dea43364a63;"> </span>   in.chunks<span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">]</span> | <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">20</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">op</span> = curlified.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>op_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>op_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">{</span> whitespace, op <span style="color: #51afef;">}</span>;
</pre>
</div>
</section>
<section id="slide-7-1">
<h3 id="7-1"><span class="section-number-3">7.1.</span> 阶段 1:1 向量化分类和伪结构字符</h3>
<aside class="notes">
<p>
we basically looking for these locations these are important loctains so that we can parse in stage 2
notice that the escaped " are not selected
this part will talk about how the authors did it in simd
the trick is to use a look up table
</p>

</aside>
<ul>
<li>想要获取结构字符的位置 ({, }, [, ], :, ,)
<ul>
<li>伪结构 - 紧跟在结构字符或空格之后的任何非空格字符</li>
<li>用于分析,我们需要此位掩码来构建磁带</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }
**1**____________1___1________1____1_______1________1___1_______
______0_____________________________________________________0___ escaped quotes "
</pre>
</div>
</section>
<section id="slide-7-1-1">
<h4 id="7-1-1"><span class="section-number-4">7.1.1.</span> 向量化分类</h4>
<aside class="notes">
<p>
We need to classify structural characters
each different class gets its own type
comma
colon
brackets, array group 4
whitespace
we need to do this classification fast we will use a look up table to do the classification, basically O(1)
notice they have only 1 bit at differnt locations
we then use movemask to split them up into bitmasks
vpshufb is done for the low 4 nibble so we can find that this is a
c a b d b d
high 4 nibble 2 3 5 5 7 7
then we do bitwise and
if we know both bytes then we can shift it to the correct
</p>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" style="font-size: 50%;">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">code points</th>
<th scope="col" class="org-left">character</th>
<th scope="col" class="org-right">desired value</th>
<th scope="col" class="org-right">bin</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0x2c</td>
<td class="org-left">`,` (comma)</td>
<td class="org-right">1</td>
<td class="org-right">00001</td>
</tr>

<tr>
<td class="org-right">0x3a</td>
<td class="org-left">`:` (colon)</td>
<td class="org-right">2</td>
<td class="org-right">00010</td>
</tr>

<tr>
<td class="org-right">0x5b</td>
<td class="org-left">`[`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x5d</td>
<td class="org-left">`]`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x7b</td>
<td class="org-left">`{`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x7d</td>
<td class="org-left">`}`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x09</td>
<td class="org-left">TAB</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x0a</td>
<td class="org-left">LF</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x0d</td>
<td class="org-left">CR</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x20</td>
<td class="org-left">SPACE</td>
<td class="org-right">16</td>
<td class="org-right">10000</td>
</tr>

<tr>
<td class="org-right">others</td>
<td class="org-left">any other</td>
<td class="org-right">0</td>
<td class="org-right">00000</td>
</tr>
</tbody>
</table>
<div class="org-src-container">

<pre class="src src-text">HIGH_4 AND LOW_4 == 0000 0100 // it must be a bracket
{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }
____________________1_______1____________1________1_____________ comma mask
_____________1_________________________________________1________ colon mask
1_________11___1_________________________________1_____________1 bracket mask
</pre>
</div>
</section>
<section id="slide-7-1-2">
<h4 id="7-1-2"><span class="section-number-4">7.1.2.</span> VPSHUFB:向量排列混排字节</h4>
<aside class="notes">
<p>
If you have any experience with hashmaps, they are actually very slow
they are not truely o(1) lookup
the only true O(1) lookup structures are actually arrays, index + offset
hashing function is a fake O(1)
if the first bit is a 0, it will look at the lower 4 nibble
like an index into an array
lets take 0x01 for example, it will go into the table here, look for the item in the first index
and put it in that location
so we get &rsquo;1&rsquo;
if the high bit is 1, then it will be null byte 0x00
we can classify 64 chars in 3-4 instructions now
that is just 4 cycles compared to a big if else
</p>

</aside>
<ul>
<li>基本上是一个使用四种最低有效位(半字节)的单指令查找表
<ul>
<li>0000 XXXX</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Lookup table for hex digits "0123456789abcdef"</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">lut</span> = _mm256_setr_epi8<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">'0'</span>, <span style="color: #98be65;">'1'</span>, <span style="color: #98be65;">'2'</span>, <span style="color: #98be65;">'3'</span>, <span style="color: #98be65;">'4'</span>, <span style="color: #98be65;">'5'</span>, <span style="color: #98be65;">'6'</span>, <span style="color: #98be65;">'7'</span>, <span style="color: #98be65;">'8'</span>, <span style="color: #98be65;">'9'</span>, <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span>, <span style="color: #98be65;">'d'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'f'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 2: Alternating normal/zeroed values (0x00,0x80,0x01,0x81...)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">indices2</span> = _mm256_setr_epi8<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">00</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">80</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">01</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">81</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">02</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">82</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">03</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">83</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">04</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">84</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">05</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">85</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">06</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">86</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">07</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">87</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">08</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">88</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">09</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">89</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0A</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8A</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0B</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8B</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0C</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8C</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0D</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8D</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0E</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8E</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0F</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8F</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   printf<span style="color: #c678dd;">(</span><span style="color: #98be65;">"\nAlternating with zeroes (. represents zero):\n"</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   print_bytes<span style="color: #c678dd;">(</span>_mm256_shuffle_epi8<span style="color: #98be65;">(</span>lut, indices2<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Alternating with zeroes (. represents zero):</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #51afef;">}</span>
<span style="color: #51afef; font-weight: bold;">#pragma</span> <span style="color: #a9a1e1;">GCC</span> target<span style="color: #51afef;">(</span><span style="color: #98be65;">"avx2"</span><span style="color: #51afef;">)</span>
<span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">immintrin.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">stdio.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">print_bytes</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">v</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">bytes</span><span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">32</span><span style="color: #c678dd;">]</span>;
<span style="color: #3dea43364a63;"> </span>   _mm256_storeu_si256<span style="color: #c678dd;">(</span><span style="color: #98be65;">(</span><span style="color: #ECBE7B;">__m256i</span>*<span style="color: #98be65;">)</span>bytes, v<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">32</span>; i++<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span>bytes<span style="color: #a9a1e1;">[</span>i<span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   printf<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"%c"</span>, bytes<span style="color: #51afef;">[</span>i<span style="color: #51afef;">]</span><span style="color: #a9a1e1;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   printf<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"."</span><span style="color: #a9a1e1;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Print dot for zero bytes</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   printf<span style="color: #c678dd;">(</span><span style="color: #98be65;">"\n"</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-7-1-3">
<h4 id="7-1-3"><span class="section-number-4">7.1.3.</span> 简单示例</h4>
<aside class="notes">
<p>
skip if no time
vpshufb is done for the low 4 nibble and high 4 nibble
if we know both bytes then we can shift it to the correct
</p>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">code points</td>
<td class="org-left">character</td>
<td class="org-right">desired value</td>
<td class="org-right">bin</td>
</tr>

<tr>
<td class="org-right">0x3a</td>
<td class="org-left">`:` (colon)</td>
<td class="org-right">2</td>
<td class="org-right">00010</td>
</tr>

<tr>
<td class="org-right">0x0a</td>
<td class="org-left">LF</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>
</tbody>
</table>
<ul>
<li>use vpshufb to match low nibble a</li>
<li>could be both : and LF so it must match 0010 | 1000 = 1010</li>
<li>low nibble at position A = 10
<ul>
<li>high nibble 0x3 vs 0x0
<ul>
<li>0x3 = 2</li>
<li>0x0 = 8</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-7-1-4">
<h4 id="7-1-4"><span class="section-number-4">7.1.4.</span> 简单示例</h4>
<pre class="example" id="org87d1505">
"LF:"
Low nibble table
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
xx xx xx xx xx xx xx xx xx xx 10 xx xx xx xx xx
1010
high nibble table
00 .. 02 03 04 05 06 07 08 09 10 11 12 13 14 15
08 .. 02 xx xx xx xx xx xx xx xx xx xx xx xx xx
0100,  0010
</pre>
</section>
<section id="slide-7-1-5">
<h4 id="7-1-5"><span class="section-number-4">7.1.5.</span> 简单示例</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">LF</td>
<td class="org-right">:</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">low</td>
<td class="org-right">1010</td>
<td class="org-right">1010</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">high</td>
<td class="org-right">1000</td>
<td class="org-right">0010</td>
</tr>

<tr>
<td class="org-left">AND</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1000</td>
<td class="org-right">0010</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">8</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-7-1-6">
<h4 id="7-1-6"><span class="section-number-4">7.1.6.</span> 阶段 1:位图到数组索引</h4>
<aside class="notes">
<p>
In stage 1, we our functions take in 64 byte * 8 bit blocks
however these masks are sparse, sometimes it can be 4 char before we a faced with a 1
sometimes the spaces are 4, and the spaces could be 40.
if we iterate through this and process it with if else statements, its unpredictable branching and will cause performance penalty, mson does this
as such we want to extract the bits into a list of indexes instead of working directly with the bitsets.
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
**1**_______1________1____1________1____1___________1_1_1____1__: Q
1_________11_1_1____1_______1____1_______1_______11____1_______1: S
_1____________1_1__________1_1____1_______1_____1__1__________1_: W
</pre>
</div>
<ul>
<li>以 Q 为例,我们要将 Q 的位掩码转换为索引列表
<ul>
<li>[2, 12, 22, 27, 37, 42, 54, 56, 58, 62]</li>

</ul></li>

</ul>
</section>
<section id="slide-7-1-7">
<h4 id="7-1-7"><span class="section-number-4">7.1.7.</span> 提取</h4>
<aside class="notes">
<p>
compiler will automatically optimize this for you
</p>

</aside>
<ul>
<li>2 条说明
<ul>
<li>TZCNT 计算尾随最不重要的 0 位</li>
<li>BLSR 删除最后设置的位。</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-text">a = 1010000
idx = tzcnt(a) // 4       count 0 after lowest bit
a = blsr(a)    // 1000000 remove lowest set bit
idx = tzcnt(a) // 6       count 0 after lowest bit
[4, 6]
</pre>
</div>
</section>
<section id="slide-7-1-8">
<h4 id="7-1-8"><span class="section-number-4">7.1.8.</span> 朴素的实现</h4>
<aside class="notes">
<p>
the compiler will automatically optimize this into the tzcnt and blsr
that while loop is the part with the unpredictable branching which will cost 10-20 cycles for every wrong prediction
how do we solve it?
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_unoptimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">pos</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This while loop is the source of unpredictable branches</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Find position of lowest set bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">bit_pos</span> = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Store the position</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = bit_pos;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear the lowest set bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-7-1-9">
<h4 id="7-1-9"><span class="section-number-4">7.1.9.</span> 最小分支实现</h4>
<aside class="notes">
<p>
unfortunately in this case it cannot avoid the if else check
so the trick we do is that we do 8 times
in one branch check
</p>

</aside>
<div class="org-src-container">

<pre style="font-size: 16px; width: 95%;"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_optimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get total number of set bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">count</span> = __builtin_popcountll<span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">next_base</span> = output + count;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Process 8 bits at a time unconditionally</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Extract next 8 set bit positions, even if we don't have 8 bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear lowest set bit (blsr instruction)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Reset output pointer to actual end based on real count</span>
<span style="color: #3dea43364a63;"> </span>   output = next_base;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-7-2">
<h3 id="7-2"><span class="section-number-3">7.2.</span> 阶段 1:2 消除转义或引用的子字符串</h3>
<div class="outline-text-3" id="text-7-2">
</div>
</section>
<section id="slide-7-2-1">
<h4 id="7-2-1"><span class="section-number-4">7.2.1.</span> 获取反斜杠</h4>
<aside class="notes">
<p>
next we have to get the quotes
the biggest problem is that we have to escape invalid quotes
this part is very logic intensive and may not make sense at first
i will just quickly go through this without explaining too much
I think you can read the paper to understand this part instead
</p>

</aside>
<div class="org-src-container">

<pre style="font-size: 16px; width: 120%; margin-left: -10%;">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
___111________________1111_______________________________111____: B = backslash_bits
____111_________________1111______________________________111___: bits_shifted_left = backslash_bits &lt;&lt; 1
___111________________1111_______________________________111____: bits
____000_________________0000______________________________000___: inverted = ~bits_shifted_left
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
// we get the first backslash of every group
</pre>
</div>
</section>
<section id="slide-7-2-2">
<h4 id="7-2-2"><span class="section-number-4">7.2.2.</span> 获取以奇数偏移量开头的奇数长度序列</h4>
<div class="org-src-container">

<pre style="font-size: 14px;">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
___111________________1111_______________________________111____: B = backslash_bits
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
___1_____________________________________________________1______: OS = S &amp; O
// add B to OS, yielding carries on backslash sequences with odd starts
___1_____________________________________________________1______: OS = S &amp; O
___111________________1111_______________________________111____: B = backslash_bits
   --&gt;                                                   --&gt;
______1_______________1111__________________________________1___: OC = B + OS
// filter out the backslashes from the previous addition, getting carries only
___111________________1111_______________________________111____: B = backslash_bits
___000________________0000_______________________________000____: ~B
______1_______________1111__________________________________1___: OC = B + OS
______1_____________________________________________________1___: OCO = OC &amp; ~B
// get the odd-length sequence starting on an odd offset and ending on even offset
______1_____________________________________________________1___: OCO = OC &amp; ~B
1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: E (constant)
______1_____________________________________________________1___: OD2 = OCO &amp; E
{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
// this shows two odd-length sequence starting on an odd offset
</pre>
</div>
</section>
<section id="slide-7-2-3">
<h4 id="7-2-3"><span class="section-number-4">7.2.3.</span> 获取以偶数偏移量开头的奇数长度序列</h4>
<p>
its just the reverse of what we done just now
</p>
<div class="org-src-container">

<pre style="width: 120%; margin-left: -10%;">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_: E (constant)
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
______________________1_________________________________________: ES = S &amp; E
___111________________1111_______________________________111____: B = backslash_bits
// add B to ES, yielding carries on backslash sequences with even starts
                      ---&gt;
___111____________________1______________________________111____: EC = B + ES
// filter out the backslashes from the previous addition, getting carries only
__________________________1_____________________________________: ECE = EC &amp; ~B
// select only the end of sequences ending on an odd offset
__________________________1_____________________________________: ECE = EC &amp; ~B
_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
________________________________________________________________: OD1 = ECE &amp; ~E
// there are no odd-length sequences of backslashes starting on an even offset
</pre>
</div>
</section>
<section id="slide-7-2-4">
<h4 id="7-2-4"><span class="section-number-4">7.2.4.</span> 获取具有奇数偏移量的序列</h4>
<div class="org-src-container">

<pre style="width: 110%; margin-left: -5%;">// merge results, yielding ends of all odd-length sequence of backslashes
________________________________________________________________: OD1 = ECE &amp; ~E
______1_____________________________________________________1___: OD2 = OCO &amp; E
______1_____________________________________________________1___: OD = OD1 | OD2
{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
// these " are escaped and thus are counted as text instead of structural characters
</pre>
</div>
</section>
<section id="slide-7-2-5">
<h4 id="7-2-5"><span class="section-number-4">7.2.5.</span> 消除转义</h4>
<aside class="notes">
<p>
this is the last step so we remove invalid quotes that are backslashed
notice the CLMUL instruction below, we will talk about that one
how to convert the start and end locations into a continuous mask
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
**1**_1_____1________1____1________1____1___________1_1_1___11__: Q = quotes
______1_____________________________________________________1___: OD
// we remove the escaped " quotes
**1**_______1________1____1________1____1___________1_1_1____1__: Q &amp;= ~OD
**1111111111**_______11111_________11111____________11__11111___: CLMUL(Q,~0)
</pre>
</div>
</section>
<section id="slide-7-2-6">
<h4 id="7-2-6"><span class="section-number-4">7.2.6.</span> 获取引号之间的位置掩码</h4>
<aside class="notes">
<p>
its basically this operation
we can use this to get the area between the quates
</p>

</aside>
<div class="org-src-container">

<pre style="font-size: 18px;"><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #c678dd;">xorShiftOperations</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">num</span>, <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">rightShift</span>, <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">tutorial</span> = <span style="color: #a9a1e1;">false</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">result</span> = num;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>; i &lt;= <span style="color: #da8548; font-weight: bold;">64</span>; i++<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   result ^= <span style="color: #98be65;">(</span>num &lt;&lt; i<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0000000000000000000010000000000000000000000000000000000000000000</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">after apply</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0000000000000000000011111111111111111111111111111111111111111111</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0001000000000000000000000000000000000000000000000000000000000000</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">after apply</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0001111111111111111111111111111111111111111111111111111111111111</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> result;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-7-2-7">
<h4 id="7-2-7"><span class="section-number-4">7.2.7.</span> 清扫</h4>
<div class="org-src-container">

<pre class="src src-text">// 0000000000000000000010000000000000000000000000000000000000000000
// OR
// 0001000000000000000000000000000000000000000000000000000000000000
// result
// 0001000000000000000010000000000000000000000000000000000000000000
// 0000000000000000000011111111111111111111111111111111111111111111
// XOR
// 0001111111111111111111111111111111111111111111111111111111111111
// result
// 0001111111111111111100000000000000000000000000000000000000000000
</pre>
</div>
</section>
<section id="slide-7-2-8">
<h4 id="7-2-8"><span class="section-number-4">7.2.8.</span> 清扫</h4>
<div class="org-src-container">

<pre class="src src-text">Final result:
0x00      00111111 11110000 00000111 11000000 00011111 00000000 00001100 11111000       0x07
Initial number:
0x00      00100000 00001000 00000100 00100000 00010000 10000000 00001010 10000100       0x07
After left shift by 1:
0x00      00110000 00001100 00000110 00110000 00011000 11000000 00001111 11000110       0x07
After left shift by 2:
0x00      00111100 00001111 00000111 10111100 00011110 11110000 00001100 00110111       0x07
After left shift by 4:
0x00      00111111 11001111 11110111 11000111 11011111 00011111 00001100 11110100       0x07
After left shift by 8:
0x00      00111111 11110000 00111000 00110000 00011000 11000000 00010011 11111000       0x07
After left shift by 16:
0x00      00111111 11110000 00000111 11000000 00100000 11110000 00001011 00111000       0x07
After left shift by 32:
0x00      00111111 11110000 00000111 11000000 00011111 00000000 00001100 11111000       0x07
</pre>
</div>
</section>
<section id="slide-7-2-9">
<h4 id="7-2-9"><span class="section-number-4">7.2.9.</span> 由 CLMUL, pclmulqdq 实现的清扫</h4>
<aside class="notes">
<p>
Why CLMUL is equivalent to the operation above?
XOR is actually the (a + b) % 2
XOR is addition without the carrying bit
then we multiply because shifting left or right is a multiply
</p>

</aside>
<ul>
<li>无进位乘法器</li>
<li>CLMUL(4, 15)</li>
<li>4 * 15</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">        4
X      15
----------
        4
X(8+4+2+1)
----------
        4
        8
       16
+      32
----------
       60
----------
</pre>
</div>
</section>
<section id="slide-7-2-10">
<h4 id="7-2-10"><span class="section-number-4">7.2.10.</span> 由 CLMUL, pclmulqdq 实现的清扫</h4>
<ul>
<li>CLMUL(4, 15)</li>
<li>XOR ~= ADD</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">         0100  (4)
   X     1111  (15)
-------------
        00100  (X1 means 4 &lt;&lt; 0)
XOR    00100_  (X2 means 4 &lt;&lt; 1)
XOR   00100__  (X4 means 4 &lt;&lt; 2)
XOR  00100___  (X8 means 4 &lt;&lt; 3)
-------------
       111100  (all XORed together)
-------------
</pre>
</div>
</section>
<section id="slide-7-2-11">
<h4 id="7-2-11"><span class="section-number-4">7.2.11.</span> 最终获取引号掩码</h4>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
**1111111111**_______11111_________11111____________11__11111___: CLMUL(Q,~0)
</pre>
</div>
</section>
<section id="slide-7-3">
<h3 id="7-3"><span class="section-number-3">7.3.</span> 阶段 1:3 字符编码验证</h3>
<aside class="notes">
<p>
next we have to validate the UTF-8
</p>
<ul>
<li>most data is ascii, first thing to do is check if the first bit of every byte is 0</li>
<li>if it is, its all validated</li>
<li>if not we go through the algorithm that the authors wrote</li>

</ul>

</aside>
<ol>
<li>初始 ASCII 快速路径,第一位 == 0</li>
<li>主要算法
<ol>
<li>范围检查(0xF4 饱和减法)</li>
<li>连续字节验证</li>

</ol></li>

</ol>
</section>
<section id="slide-7-3-1">
<h4 id="7-3-1"><span class="section-number-4">7.3.1.</span> 检查 Ascii 快速路径</h4>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data
</pre>
</div>
</section>
<section id="slide-7-3-2">
<h4 id="7-3-2"><span class="section-number-4">7.3.2.</span> 连续字节验证</h4>
<aside class="notes">
<p>
i had showed this just now so we have to detect this pattern
if it is 110 then the next must be 10 to be valid
if its 00 then its nat valid lets see how they
implement this in simd
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data
Two bytes:
110xxxxx 10xxxxxx           (values 128-2047)
First byte starts with 110
Three bytes:
1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
First byte starts with 1110
Four bytes:
1111xxxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
First byte starts with 11110
</pre>
</div>
</section>
<section id="slide-7-3-3">
<h4 id="7-3-3"><span class="section-number-4">7.3.3.</span> 映射到值(再次 VPSHUFB!)</h4>
<aside class="notes">
<p>
we look at the high nibble for this since only the high nibble is involved
if it is ascii, we use the lookup table to get it to 1
if it is 10xx we set it to 0
if 1100 2
1110 3
1111 4
look at the example below, notice a pattern?
it will be 4000 if it is length 4, length 3 is 300
</p>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">high</th>
<th scope="col" class="org-right">Dec</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">high</th>
<th scope="col" class="org-right">Dec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1001</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1010</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1011</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1100</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1101</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1110</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1111</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>
<div class="org-src-container">

<pre class="src src-text">1111xxxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
4 0 0 0
1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
3 0 0
</pre>
</div>
</section>
<section id="slide-7-3-4">
<h4 id="7-3-4"><span class="section-number-4">7.3.4.</span> SIMD 验证算法</h4>
<aside class="notes">
<p>
this is the algorithm, we shift right-1 add back
shift 2 minus 2 add back
notice we get a 4 3 2 1 3 2 1 1 1 1
at the end of it, there should be nothing bigger than 4
and no 0 if have 0 its wrong
next show example of a wrong one
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">4 0 0 0 3 0 0 2 0 1 1 1
  4 0 0 0 3 0 0 2 0 1 1 1 // &lt;&lt;= 1 byte, shift left by 1 byte
  3 0 0 0 2 0 0 1 0 0 0 0 // saturated subtract 1 from each byte
4 0 0 0 3 0 0 2 0 1 1 1
  3 0 0 0 2 0 0 1 0 0 0 0
4 3 0 0 3 2 0 2 1 1 1 1   // add it back into the original mapping
4 3 0 0 3 2 0 2 1 1 1 1   // add it back into the original mapping
    4 3 0 0 3 2 0 2 1 1 1 1   // &lt;&lt;= 2 byte, shift left by 2 bytes
    2 1 0 0 1 0 0 0 0 0 0 0   // saturated subtract 2
4 3 2 1 3 2 1 3 1 1 1 1   // add it back
// the end result will have no 0
// none of the numbers are bigger than the original
</pre>
</div>
</section>
<section id="slide-7-3-5">
<h4 id="7-3-5"><span class="section-number-4">7.3.5.</span> SIMD 验证算法:无效示例</h4>
<aside class="notes">
<p>
look at this part, after 4 its supposed to be 4000
but i put a 3 there
lets look at a bad example
we do the same steps shuft left subtract 1
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">2 0 0 0 4 3 0 0
  2 0 0 0 4 3 0 // shift left 1
  1 0 0 0 3 2 0 // saturated subtract 1
2 1 0 0 4 6 2 0
2 1 0 0 4 6 2 0
    0 0 2 1 0 0 4 6 // shift left 2
    0 0 0 0 0 0 2 4 // saturated subtract 2
2 1 0 0 4 6 4 4
2 0 0 0 4 3 0 0
2 1 0 0 4 6 4 4
    --- zeros found here invalid
          - 6 &gt; 3
</pre>
</div>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> 阶段 2:构建磁带</h2>
<div class="outline-text-2" id="text-8">
</div>
</section>
<section id="slide-8-1">
<h3 id="8-1"><span class="section-number-3">8.1.</span> 阶段 2:磁带</h3>
<div class="outline-text-3" id="text-8-1">
</div>
</section>
<section id="slide-8-1-1">
<h4 id="8-1-1"><span class="section-number-4">8.1.1.</span> 磁带条目的三个类别</h4>
<aside class="notes">
<p>
after finding the location of everything and
knowing that it is valid
i will go through how they make this tape and parse the values
a tape is made up of entries, each entry is 64 byte
this is for byte alignment
direct values are the simplest
n must be null, t must be true, f must be false
numbers will take 2 entry 128 bytes
strings take 1 entry and point to another buffer where the real string is at
this allows our stucture to be quickly traversable and not polluted with strings of unknown length
last is the structural entrys
they take 1 entry and the data on the right is the location of the other end of the bracket
in the tape
allows us to skip arrays and objects if we want to
</p>

</aside>
<ol>
<li>直接值(原子)
<ul>
<li>null、true、false</li>
<li>数字(整数和浮点数) - 占用 2 个磁带条目</li>

</ul></li>
<li>字符串引用
<ul>
<li>指向单独的字符串缓冲区</li>
<li>不是原始 JSON 字符串</li>

</ul></li>
<li>结构化导航
<ul>
<li>数组括号 [,]</li>
<li>对象大括号 {,}</li>
<li>包含跳转索引</li>

</ul></li>

</ol>
</section>
<section id="slide-8-1-2">
<h4 id="8-1-2"><span class="section-number-4">8.1.2.</span> 基本结构</h4>
<aside class="notes">
<p>
so for string and structural
the payload is the offset to the buffer
jump index to the other location of the structure in the tape
else the other one is a type marker
</p>

</aside>
<ul>
<li>磁带是 64 位字的数组</li>
<li>每个条目:=TYPE_MARKER × 2^56 + payload=</li>
<li>高 8 位:类型信息</li>
<li>低 56 位:值或引用</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">63      56 55                   0
+--------+----------------------+
|  TYPE  |     PAYLOAD          |
+--------+----------------------+
   8 bits      56 bits
</pre>
</div>
</section>
<section id="slide-8-1-3">
<h4 id="8-1-3"><span class="section-number-4">8.1.3.</span> 直接值(原子)</h4>
<aside class="notes">
<p>
these just tell you the type
n for null
t for true
f for false
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">01101110 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'n' null
Hex: 0x6E00000000000000
01110100 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'t' true
Hex: 0x7400000000000000
01100110 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'f' false
Hex: 0x6600000000000000
</pre>
</div>
</section>
<section id="slide-8-1-4">
<h4 id="8-1-4"><span class="section-number-4">8.1.4.</span> 数字:整数示例(42)</h4>
<p>
占用 2 个磁带条目:
-第一个只是一个类型标记
-第二个是值
</p>
<div class="org-src-container">

<pre class="src src-text">Entry 1 (type marker):
01101100 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'l'
Hex: 0x6C00000000000000
Entry 2 (value):
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00101010
                                                                 ^42
Hex: 0x000000000000002A
</pre>
</div>
</section>
<section id="slide-8-1-5">
<h4 id="8-1-5"><span class="section-number-4">8.1.5.</span> 数字:浮点示例(3.14)</h4>
<p>
占用 2 个磁带条目:
</p>
<div class="org-src-container">

<pre class="src src-text">Entry 1 (type marker):
01100100 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'d'
Hex: 0x6400000000000000
Entry 2 (value in IEEE 754):
01000000 00001001 00011110 10111000 01010100 01000000 00000000 00000000
Hex: 0x4009219940000000
</pre>
</div>
</section>
<section id="slide-8-1-6">
<h4 id="8-1-6"><span class="section-number-4">8.1.6.</span> 字符串磁带条目</h4>
<div class="org-src-container">

<pre class="src src-text">Example for "..........hello":
Binary:
00100010 00000000 00000000 00000000 00000000 00000000 00000000 00001010
   ^'"'                                                         ^offset=10
Hex: 0x220000000000000A
</pre>
</div>
<ul>
<li>字符串缓冲区是一个单独的数组,用于存储标准化的 UTF-8 字符串</li>

</ul>
<ol class="org-ol">
<li><a id="8-1-6-1"></a>这种方法的好处<br />
<ul>
<li>快速的长度检索 - 无需在磁带中进行可变长度猜测搜索</li>
<li>包含标准化的 UTF-8 字符串</li>

</ul>
</li>
</ol>
</section>
<section id="slide-8-1-7">
<h4 id="8-1-7"><span class="section-number-4">8.1.7.</span> 对象示例</h4>
<div class="org-src-container">

<pre class="src src-text">{"name": "John"}
Opening brace (points forward):
Binary:
01111011 00000000 00000000 00000000 00000000 00000000 00000000 00000010
   ^'{'                                                         ^next=2
Hex: 0x7B00000000000002
Closing brace (points backward):
Binary:
01111101 00000000 00000000 00000000 00000000 00000000 00000000 00000000
   ^'}'                                                         ^prev=0
Hex: 0x7D00000000000000
</pre>
</div>
</section>
<section id="slide-8-1-8">
<h4 id="8-1-8"><span class="section-number-4">8.1.8.</span> 数组示例</h4>
<aside class="notes">
<p>
see here i can have this index here to jump to the other side without reading the array
next noe is more important
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">array = [1,2,3]
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">addr</th>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">char</th>
<th scope="col" class="org-right">tape entry</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">array</td>
<td class="org-left">[&#x2013;8</td>
<td class="org-right">0x5B00000000000008</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">integer</td>
<td class="org-left">l</td>
<td class="org-right">0x6C00000000000000</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">value</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0x0000000000000001</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">integer</td>
<td class="org-left">l</td>
<td class="org-right">0x6C00000000000000</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">value</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0x0000000000000002</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">integer</td>
<td class="org-left">l</td>
<td class="org-right">0x6C00000000000000</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">value</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0x0000000000000003</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">array</td>
<td class="org-left">]&#x2013;0</td>
<td class="org-right">0x5D00000000000000</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">other</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">other</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-8-1-9">
<h4 id="8-1-9"><span class="section-number-4">8.1.9.</span> JSON 文档</h4>
<aside class="notes">
<p>
this is just an example of how an object would look like
</p>

</aside>
<div class="org-src-container">

<pre class="src src-json">{
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">"name"</span>: <span style="color: #98be65;">"John"</span>,
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">"age"</span>: <span style="color: #da8548; font-weight: bold;">42</span>,
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">"active"</span>: <span style="color: #a9a1e1;">true</span>
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-text">Idx  Type    Payload   Description
0:   'r'     12        Root (points to end)
1:   '{'     12        Object start (points to end)
2:   '"'     100       String "name" (points to string buffer offset 100)
3:   '"'     150       String "John" (points to string buffer offset 150)
4:   '"'     200       String "age" (points to string buffer offset 200)
5:   'l'     0         Integer marker
6:   -       42        Integer value
7:   '"'     250       String "active" (points to string buffer offset 250)
8:   't'     0         true value
9:   '}'     1         Object end (points to start)
10:  'r'     0         Root end (points to start)
</pre>
</div>
</section>
<section id="slide-8-1-10">
<h4 id="8-1-10"><span class="section-number-4">8.1.10.</span> 磁带优势</h4>
<ul>
<li>缓存友好的线性布局</li>
<li>使用索引跳转快速导航</li>
<li>SIMD 友好的处理</li>
<li>可预测的内存布局</li>

</ul>
</section>
<section id="slide-8-2">
<h3 id="8-2"><span class="section-number-3">8.2.</span> 阶段 2:1 数字解析</h3>
<div class="outline-text-3" id="text-8-2">
</div>
</section>
<section id="slide-8-2-1">
<h4 id="8-2-1"><span class="section-number-4">8.2.1.</span> 了解 is_all_digits</h4>
<aside class="notes">
<p>
when parsing for numbers, there is no choice but to use if else
however the authors noticed many numbers are longer than 8 digits
so they develop a way to check and parse numbers of 8 digit size
this is the algo for fast digit check
we run this exact algorithm and if the output is 3333
it must all be digits, let me explain why
</p>

</aside>
<p>
快速 8 位数检查
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint64</span> <span style="color: #dcaeea;">high_nibble</span> = val &amp; <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">F0F0F0F0F0F0F0F0</span>;
<span style="color: #ECBE7B;">uint64</span> <span style="color: #dcaeea;">low_nibble</span> = <span style="color: #51afef;">(</span><span style="color: #c678dd;">(</span>val + <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0606060606060606</span><span style="color: #c678dd;">)</span> &amp; <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">F0F0F0F0F0F0F0F0</span><span style="color: #51afef;">)</span> &gt;&gt; <span style="color: #da8548; font-weight: bold;">4</span>;
<span style="color: #ECBE7B;">uint64</span> <span style="color: #dcaeea;">combined</span> = high_nibble | low_nibble;
<span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">is_all_digits</span> = combined == <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">3333333333333333</span>;
</pre>
</div>
</section>
<section id="slide-8-2-2">
<h4 id="8-2-2"><span class="section-number-4">8.2.2.</span> 主要见解:0x29 到 0x3A 的 ASCII 字符</h4>
<aside class="notes">
<p>
So there are 2 things to check, less than 0x30 which is 0x2F up here
0x3A which is bigger than 9 0x39 down here
see a pattern notice all of these are 3
and notice the one behind is 0123..9
</p>

</aside>
<ul>
<li>请注意,有效数字的所有高半字节均为 3</li>

</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" style="font-size: 80%;">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Char</th>
<th scope="col" class="org-right">Hex</th>
<th scope="col" class="org-left">Binary</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&rsquo;/&rsquo;</td>
<td class="org-right">0x2F</td>
<td class="org-left">0010 1111</td>
<td class="org-left">Forward Slash</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&rsquo;0&rsquo;</td>
<td class="org-right">0x30</td>
<td class="org-left">0011 0000</td>
<td class="org-left">Digit Zero</td>
<td class="org-left">&lt;&#x2013; Valid digits start</td>
</tr>

<tr>
<td class="org-left">&rsquo;1&rsquo;</td>
<td class="org-right">0x31</td>
<td class="org-left">0011 0001</td>
<td class="org-left">Digit One</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;2&rsquo;</td>
<td class="org-right">0x32</td>
<td class="org-left">0011 0010</td>
<td class="org-left">Digit Two</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;3&rsquo;</td>
<td class="org-right">0x33</td>
<td class="org-left">0011 0011</td>
<td class="org-left">Digit Three</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;4&rsquo;</td>
<td class="org-right">0x34</td>
<td class="org-left">0011 0100</td>
<td class="org-left">Digit Four</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;5&rsquo;</td>
<td class="org-right">0x35</td>
<td class="org-left">0011 0101</td>
<td class="org-left">Digit Five</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;6&rsquo;</td>
<td class="org-right">0x36</td>
<td class="org-left">0011 0110</td>
<td class="org-left">Digit Six</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;7&rsquo;</td>
<td class="org-right">0x37</td>
<td class="org-left">0011 0111</td>
<td class="org-left">Digit Seven</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;8&rsquo;</td>
<td class="org-right">0x38</td>
<td class="org-left">0011 1000</td>
<td class="org-left">Digit Eight</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&rsquo;9&rsquo;</td>
<td class="org-right">0x39</td>
<td class="org-left">0011 1001</td>
<td class="org-left">Digit Nine</td>
<td class="org-left">&lt;&#x2013; Valid digits end</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&rsquo;:&rsquo;</td>
<td class="org-right">0x3A</td>
<td class="org-left">0011 1010</td>
<td class="org-left">Colon</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-8-2-3">
<h4 id="8-2-3"><span class="section-number-4">8.2.3.</span> 步骤 1:高半字节的初始掩码</h4>
<aside class="notes">
<p>
lets go throuh an example first check must be that the
high nibble is all 3
very easy in c++ it looks like this
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint64</span> <span style="color: #dcaeea;">high_nibble</span> = val &amp; <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">F0F0F0F0F0F0F0F0</span>;
</pre>
</div>
<ul>
<li>如果您小于 0x3X,则为 0x2F,</li>
<li>让我们采用有效输入“12345678”:</li>

</ul>
<pre class="example" id="org48e20b1">
Input bytes:    31 32 33 34 35 36 37 38
                || || || || || || || ||
                v| v| v| v| v| v| v| v|
High nibble:    3  3  3  3  3  3  3  3
                |  |  |  |  |  |  |  |
Mask:           F0 F0 F0 F0 F0 F0 F0 F0
                =  =  =  =  =  =  =  =
Result1:        30 30 30 30 30 30 30 30
</pre>
</section>
<section id="slide-8-2-4">
<h4 id="8-2-4"><span class="section-number-4">8.2.4.</span> 低半字节检查的工作原理</h4>
<aside class="notes">
<p>
we want this range to be illegal
we do that with carry bit detection
if we add some number, it will over flow and affect the next bit and cause the number to be bigger than 3
</p>

</aside>
<ul>
<li>我们要确保低半字节在 0xX0 - 0xX9 范围内
<ul>
<li>0xXA - 0xXF 是非法的
<ul>
<li>使用二进制分析进位检测</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-8-2-5">
<h4 id="8-2-5"><span class="section-number-4">8.2.5.</span> 情况 1:有效数字(0x39 = &rsquo;9&rsquo;)</h4>
<aside class="notes">
<p>
they chose 0110 is because 9 + 6 = 15
it is still within
imagine if the value is 10, invalid, + 6 will overflow
</p>

</aside>
<pre class="example" id="org0d15bc2">
0x39 = 0011 1001  (Original value '9')
0x06 = 0000 0110  (Value we add)
      -----------
      0011 1111  (Result = 0x3F)
Low nibble does not overflow into high nibble and affect the 0x3 in high nibble
After masking high nibble (&amp; 0xF0):
0x3F = 0011 1111
0xF0 = 1111 0000
      -----------
      0011 0000  (= 0x30)
After right shift by 4:
0x30 &gt;&gt; 4 = 0000 0011  (= 0x03) ✓ Valid!
</pre>
</section>
<section id="slide-8-2-6">
<h4 id="8-2-6"><span class="section-number-4">8.2.6.</span> 情况 2:无效字符(0x3A = &rsquo;:&rsquo;)</h4>
<pre class="example" id="org9222a2b">
0x3A = 0011 1010  (Original value ':')
0x06 = 0000 0110  (Value we add)
      -----------
       0011 0000
          1 0000
      -----------
      0100 0000  (Result = 0x40) &lt;- Notice the carry!
                                   The '1' carried into the high nibble
After masking high nibble (&amp; 0xF0):
0x40 = 0100 0000
0xF0 = 1111 0000
      -----------
      0100 0000  (= 0x40)
After right shift by 4:
0x40 &gt;&gt; 4 = 0000 0100  (= 0x04) ✗ Invalid!
0x3X
|0xX4
-----
0x34 &lt;- INVALID
-----
</pre>
</section>
<section id="slide-8-2-7">
<h4 id="8-2-7"><span class="section-number-4">8.2.7.</span> 步骤 2:添加 0x06 以检测非数字</h4>
<pre class="example" id="org7e15a24">
Low nibbles:    1  2  3  4  5  6  7  8
Add 0x06:       7  8  9  A  B  C  D  E
                ^  ^  ^  ^  ^  ^  ^  ^
                |  |  |  |  |  |  |  |
If original &lt;= 9: No carry to high nibble
If original &gt; 9: Carry affects high nibble
</pre>
</section>
<section id="slide-8-2-8">
<h4 id="8-2-8"><span class="section-number-4">8.2.8.</span> 步骤 3:有效数字(0-9)的示例</h4>
<aside class="notes">
<p>
skip
</p>

</aside>
<p>
Take &ldquo;12345678&rdquo;:
</p>
<pre class="example" id="org8a37d6c">
Original:       31 32 33 34 35 36 37 38
                v  v  v  v  v  v  v  v
high nibble:    30 30 30 30 30 30 30 30
Original:       31 32 33 34 35 36 37 38
After +0x06:    37 38 39 3A 3B 3C 3D 3E
                               ^  ^  ^  ^
If original &gt; 9, carry effects the high nibble &gt;3
Mask high:      30 30 30 30 30 30 30 30
Shift right 4:  03 03 03 03 03 03 03 03
OR together:    33 33 33 33 33 33 33 33
</pre>
</section>
<section id="slide-8-2-9">
<h4 id="8-2-9"><span class="section-number-4">8.2.9.</span> 步骤 4:无效字符(&rsquo;;&rsquo; = 0x3B)的示例</h4>
<p>
Take &ldquo;1234;678&rdquo;:
</p>
<pre class="example" id="org77d8657">
Original:       31 32 33 34 3B 36 37 38
After +0x06:    37 38 39 3A 41 3C 3D 3E
                               ^
                               |
Mask high:      30 30 30 30 40 30 30 30
                               ^ Different!
Shift right 4:  03 03 03 03 04 03 03 03
high nibble:    30 30 30 30 30 30 30 30
OR together:    33 33 33 33 34 33 33 33 ≠ 0x3333...
                               ^ Caught!
</pre>
</section>
<section id="slide-8-2-10">
<h4 id="8-2-10"><span class="section-number-4">8.2.10.</span> 它为什么有效</h4>
<aside class="notes">
<p>
skip
</p>

</aside>
<ol>
<li>第一部分 (val &amp; 0xF0F0&#x2026;):
<ul>
<li>隔离高半字节</li>
<li>对于有效数字,必须为 0x30</li>

</ul></li>
<li>第二部分 ((val + 0x06&#x2026;) &amp; 0xF0&#x2026;):
<ul>
<li>将 0x06 添加到低半字节:
<ul>
<li>对于 0-9:结果保持在半字节内</li>
<li>对于&gt;9:导致进位</li>

</ul></li>
<li>右移 4 位后:
<ul>
<li>有效数字:始终为 0x03</li>
<li>无效:不同的值</li>

</ul></li>

</ul></li>
<li>当 OR 在一起时:
<ul>
<li>有效数字:始终为 0x33</li>
<li>无效:不同的模式</li>

</ul></li>

</ol>
</section>
<section id="slide-8-2-11">
<h4 id="8-2-11"><span class="section-number-4">8.2.11.</span> 有效案例</h4>
<pre class="example" id="org8caf51c">
"00000000" -&gt; 0x3333333333333333 ✓
"99999999" -&gt; 0x3333333333333333 ✓
"12345678" -&gt; 0x3333333333333333 ✓
</pre>
</section>
<section id="slide-8-2-12">
<h4 id="8-2-12"><span class="section-number-4">8.2.12.</span> 无效案例</h4>
<pre class="example" id="orgdf7d44b">
"A" (0x41):
Original:  41
+0x06:     47
High:      40 ≠ 30 -&gt; Fails
"/" (0x2F):
Original:  2F
+0x06:     35
High:      20 ≠ 30 -&gt; Fails
":" (0x3A):
Original:  3A
+0x06:     40
High:      40 ≠ 30 -&gt; Fails
</pre>
</section>
<section id="slide-8-2-13">
<h4 id="8-2-13"><span class="section-number-4">8.2.13.</span> 性能优势</h4>
<ul>
<li>单个比较而不是 8 个单独的检查</li>
<li>没有分支(对于现代 CPU 而言很重要)</li>
<li>使用本机 64 位操作</li>
<li>利用 CPU 并行检查的能力</li>

</ul>
<p>
此算法是位操作的一个很好的示例,它将通常为 8 个比较转变为单个数学测试。
</p>
</section>
<section id="slide-8-2-14">
<h4 id="8-2-14"><span class="section-number-4">8.2.14.</span> 了解基于 SIMD 的快速八位数字数解析</h4>
<aside class="notes">
<p>
after we know that it is all digits,
we need to parse the number into a valid number
we wrote this algo before
the authors did a simd version which looks like this
it looks scary
i will explain each step
notice the weird pattern 10 1 10 1
notice the weird pattern 100 1 100 1
notice the weird pattern 10000 1 10000 1
you may already guess what is going to happen
</p>

</aside>
<p>
使用 SIMD 指令将 8 位数的 ASCII 字符串转换为整数。
示例:“12345678”-&gt; 12345678
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint32_t</span> <span style="color: #c678dd;">parse_eight_digits_unrolled</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">chars</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">ascii0</span> = _mm_set1_epi8<span style="color: #c678dd;">(</span>&#8217;<span style="color: #da8548; font-weight: bold;">0</span>&#8217;<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10</span> = _mm_setr_epi8<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_100</span> = _mm_setr_epi16<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">number_ascii</span> = _mm_loadu_si128<span style="color: #c678dd;">(</span><span style="color: #98be65;">(</span><span style="color: #ECBE7B;">__m128i</span> *<span style="color: #98be65;">)</span>chars<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">in</span> = _mm_sub_epi8<span style="color: #c678dd;">(</span>number_ascii, ascii0<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t1</span> = _mm_maddubs_epi16<span style="color: #c678dd;">(</span>in, mul_1_10<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t2</span> = _mm_madd_epi16<span style="color: #c678dd;">(</span>t1, mul_1_100<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t3</span> = _mm_packus_epi32<span style="color: #c678dd;">(</span>t2, t2<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t4</span> = _mm_madd_epi16<span style="color: #c678dd;">(</span>t3, mul_1_10000<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> _mm_cvtsi128_si32<span style="color: #c678dd;">(</span>t4<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-8-2-15">
<h4 id="8-2-15"><span class="section-number-4">8.2.15.</span> 步骤 1:将 ASCII 转换为数值</h4>
<aside class="notes">
<p>
remove the high nibble so that they are int8
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">ascii0</span> = _mm_set1_epi8<span style="color: #51afef;">(</span>&#8217;<span style="color: #da8548; font-weight: bold;">0</span>&#8217;<span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">number_ascii</span> = _mm_loadu_si128<span style="color: #51afef;">(</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">__m128i</span> *<span style="color: #c678dd;">)</span>chars<span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">in</span> = _mm_sub_epi8<span style="color: #51afef;">(</span>number_ascii, ascii0<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org913cf7e">
Input:          "12345678"
ASCII values:   31 32 33 34 35 36 37 38
Subtract:       30 30 30 30 30 30 30 30
Subtract '0':   01 02 03 04 05 06 07 08  (numeric values)
                |  |  |  |  |  |  |  |
Instruction:    _mm_sub_epi8 (PSUBB - packed subtract bytes)
</pre>
</section>
<section id="slide-8-2-16">
<h4 id="8-2-16"><span class="section-number-4">8.2.16.</span> 步骤 2:将备用数字乘以 10 并添加</h4>
<aside class="notes">
<p>
notice the weird pattern 10 1 10 1
multiply the one infront by 10
add them to each other
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10</span> = _mm_setr_epi8<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t1</span> = _mm_maddubs_epi16<span style="color: #51afef;">(</span>in, mul_1_10<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org65d78c4">
Values:         1  2  3  4  5  6  7  8
Multipliers:   10  1 10  1 10  1 10  1
                |  |  |  |  |  |  |  |
Results:       10  2 30  4 50  6 70  8
                \ /   \ /   \ /   \ /
Sums:           12    34    56    78     (as 16-bit values)
Instruction: _mm_maddubs_epi16 (PMADDUBSW - multiply and add unsigned bytes to signed words)
</pre>
</section>
<section id="slide-8-2-17">
<h4 id="8-2-17"><span class="section-number-4">8.2.17.</span> 步骤 3:将备用 16 位值乘以 100</h4>
<aside class="notes">
<p>
then we do the same thing again
100
next is it 10000?
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_100</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t2</span> = _mm_madd_epi16<span style="color: #51afef;">(</span>t1, mul_1_100<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="orge2feac6">
Values:        12   34   56   78
Multipliers:  100    1  100    1
                |    |    |    |
Results:     1200   34 5600   78
                 \ /       \ /
Sums:           1234      5678    (as 32-bit values)
Instruction: _mm_madd_epi16 (PMADDWD - multiply and add packed words)
</pre>
<ul>
<li>下一步是什么?10000?</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
</pre>
</div>
</section>
<section id="slide-8-2-18">
<h4 id="8-2-18"><span class="section-number-4">8.2.18.</span> 步骤 4:将 32 位值打包到 16 位</h4>
<ul>
<li>将值重新解释为 32 位而不是 16 位!?为什么?</li>
<li>因此我们可以使用~_mm_setr_epi16~而不是~_mm_setr_epi32~
<ul>
<li>它更有效</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint16</span> <span style="color: #dcaeea;">max_value</span> = <span style="color: #da8548; font-weight: bold;">65536</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t3</span> = _mm_packus_epi32<span style="color: #51afef;">(</span>t2, t2<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org086a816">
Before:   1234(32-bit)  5678(32-bit)
After:    1234(16-bit)  5678(16-bit)
Instruction: _mm_packus_epi32 (PACKUSDW - pack with unsigned saturation)
</pre>
</section>
<section id="slide-8-2-19">
<h4 id="8-2-19"><span class="section-number-4">8.2.19.</span> 步骤 5:使用乘以 10000 的最终组合</h4>
<aside class="notes">
<p>
finally we do the 10000 and get the answer
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t4</span> = _mm_madd_epi16<span style="color: #51afef;">(</span>t3, mul_1_10000<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org24e3eae">
Values:        1234     5678
Multipliers:  10000        1
                  |        |
Results:   12340000     5678
                   \   /
Sum:           12345678    (final 32-bit result)
Instruction: _mm_madd_epi16 (PMADDWD again)
</pre>
</section>
<section id="slide-8-2-20">
<h4 id="8-2-20"><span class="section-number-4">8.2.20.</span> 摘要:为什么这么快</h4>
<aside class="notes">
<p>
simd fast
save instructions
it takes aronud 17 cycles instead of much more
</p>

</aside>
<ol>
<li>并行处理:
<ul>
<li>同时处理多个数字</li>
<li>高效地使用 CPU 的 SIMD 功能</li>

</ul></li>
<li>指令计数:
<ul>
<li>传统: ~8 个加载 + ~8 个乘法 + ~7 加法 ~23 个实例</li>
<li>SIMD: ~7 个总指令</li>

</ul></li>
<li>Haswell 的延迟分析:
<ul>
<li>PSUBB(减):1 个周期</li>
<li>PMADDUBSW(乘法加法字节):5 个周期</li>
<li>PMADDWD(乘法加法字):5 个周期</li>
<li>PACKUSDW(打包):1 个周期</li>
<li>总延迟:~17 个周期</li>

</ul></li>

</ol>
</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> 代码库中的实际 c++ 代码实现和优化技巧</h2>
<div class="outline-text-2" id="text-9">
</div>
</section>
<section id="slide-9-1">
<h3 id="9-1"><span class="section-number-3">9.1.</span> SIMD8 零成本 “抽象”</h3>
<aside class="notes">
<p>
actual coding style
how they made their life easier
this is how they made their classes
heavy reuse of templating
</p>

</aside>
<div class="org-src-container">

<pre style="font-size: 40%; width: 50%">                          +---------------------+
                          |    base&lt;Child&gt;      |
                          +---------------------+
                                    &#9474;
                                    &#9474;
                     +--------------&#9524;--------------+
                     |                             |
              (for T &#8800; bool)                   (for bool)
                     |                             |
              +------&#9660;------+                +------&#9660;------+
              |   base8&lt;T&gt;  |                | base8&lt;bool&gt; |
              +-------------+                +-------------+
                     &#9474;                             &#9474;
                     &#9474;                             &#9474;
            +--------&#9660;--------+                    &#9474;
            | base8_numeric&lt;T&gt;|                    &#9474;
            +-----------------+                    &#9474;
                     &#9474;                       +-----&#9660;-----+
           +---------&#9524;---------+             |simd8&lt;bool&gt;|
           |                   |             +-----------+
           |                   |
   +-------&#9660;-------+   +-------&#9660;-------+
   | simd8&lt;int8_t&gt; |   | simd8&lt;uint8_t&gt;|
   +---------------+   +---------------+
base&lt;simd8&lt;uint8_t&gt;&gt;     // Base template
    &#8593;
base8&lt;uint8_t&gt;          // Adds common SIMD operations
    &#8593;
base8_numeric&lt;uint8_t&gt;  // Adds numeric operations
    &#8593;
simd8&lt;uint8_t&gt;         // Final implementation
</pre>
</div>
</section>
<section id="slide-9-1-1">
<h4 id="9-1-1"><span class="section-number-4">9.1.1.</span> 质量至上的抽象</h4>
<aside class="notes">
<p>
they overwrote the max min &lt;= &gt;= operators to make using simd intuitive
look here got add substract bla bla
</p>

</aside>
<div class="org-src-container">

<pre style="width: 140%; margin-left: -20%;"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;&gt;</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>: <span style="color: #ECBE7B;">base8_numeric</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Saturated math</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">saturating_add</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_adds_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">saturating_sub</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_subs_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Order-specific operations</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">max_val</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_max_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">min_val</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_min_epu8<span style="color: #98be65;">(</span>other, *<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Same as &gt;, but only guarantees true is nonzero (&lt; guarantees true = -1)</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">gt_bits</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;saturating_sub<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Same as &lt;, but only guarantees true is nonzero (&lt; guarantees true = -1)</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">lt_bits</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.saturating_sub<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&lt;=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.max_val<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span> == other; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&gt;=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.min_val<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span> == other; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&gt;</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;gt_bits<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>.any_bits_set<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&lt;</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;lt_bits<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>.any_bits_set<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
</section>
<section id="slide-9-1-2">
<h4 id="9-1-2"><span class="section-number-4">9.1.2.</span> 质量至上的抽象</h4>
<aside class="notes">
<p>
same thing
</p>

</aside>
<div class="org-src-container">

<pre style="width: 140%; margin-left: -20%;"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Bit-specific operations</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">bits_not_set</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> *<span style="color: #51afef;">this</span> == uint8_t<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">bits_not_set</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span> &amp; bits<span style="color: #c678dd;">)</span>.bits_not_set<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">any_bits_set</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> ~<span style="color: #51afef;">this</span>-&gt;bits_not_set<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">any_bits_set</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> ~<span style="color: #51afef;">this</span>-&gt;bits_not_set<span style="color: #c678dd;">(</span>bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">is_ascii</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_movemask_epi8<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span><span style="color: #c678dd;">)</span> == <span style="color: #da8548; font-weight: bold;">0</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">bits_not_set_anywhere</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_testz_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, *<span style="color: #51afef;">this</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">any_bits_set_anywhere</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef; font-weight: bold;">!</span>bits_not_set_anywhere<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">bits_not_set_anywhere</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_testz_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">any_bits_set_anywhere</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef; font-weight: bold;">!</span>bits_not_set_anywhere<span style="color: #c678dd;">(</span>bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">shr</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> simd8<span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;(</span>_mm256_srli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> &amp; uint8_t<span style="color: #c678dd;">(</span><span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">FF</span><span style="color: #51afef;">u</span> &gt;&gt; N<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">shl</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> simd8<span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;(</span>_mm256_slli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> &amp; uint8_t<span style="color: #c678dd;">(</span><span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">FF</span><span style="color: #51afef;">u</span> &lt;&lt; N<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get one of the bits and make a bitmask out of it.</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">e.g. value.get_bit&lt;7&gt;() gets the high bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">get_bit</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_movemask_epi8<span style="color: #c678dd;">(</span>_mm256_slli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, <span style="color: #da8548; font-weight: bold;">7</span>-N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-9-2">
<h3 id="9-2"><span class="section-number-3">9.2.</span> 模板元编程和 CRTP 与虚函数(动态绑定)</h3>
<aside class="notes">
<p>
here iis the thing
this template meta programming means using template which is a direct substitution that is known at compile time
this allows the LLVM to aggresively inline code
inlining allows for max information so it can optimize properly
The compiler can inline these functions, reducing function call overhead.
no virtual function
no run time indirection. Since the dispatch is resolved at compile time, there&rsquo;s no need for a vtable lookup.
</p>

</aside>
<ul>
<li><b><b>使用模板/CRTP 进行编译时多态性:</b></b>
<ul>
<li><b><b>零成本抽象:</b></b> CRTP 模式允许编译器在编译时解析函数调用。
<ul>
<li><span class="underline">来自 simdjson 的示例:</span></li>

</ul></li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">Child</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded operator (inline, no vtable overhead)</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">Child</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> _mm256_or_si256<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
<ul>
<li><b><b>内联和优化</b></b></li>
<li><b><b>没有运行时重定向</b></b></li>

</ul>
</section>
<section id="slide-9-2-1">
<h4 id="9-2-1"><span class="section-number-4">9.2.1.</span> 使用虚函数进行动态绑定</h4>
<aside class="notes">
<p>
they prefer early binding in template rather than virtual functions
virtual functions are like interfaces in java
the reason why java is still fast when doing this is because
java has a JIT, c++ does not
java can optimize code at runtime by observation
while c++ must be optimized at compile time
</p>
<ul>
<li><b><b>运行时开销:</b></b>
<ul>
<li>每个调用都会产生额外的间接寻址(vtable 查找)。</li>
<li>虚调用通常不会内联,因为确切的函数仅在运行时才知道。</li>

</ul></li>
<li><b><b>类似于 Java 接口:</b></b>
<ul>
<li>在 Java 中,接口方法(或虚方法)在运行时分派。虽然 JIT 有时可以在它检测到热路径时内联此类调用,但 C++ 没有 JIT 并且完全依赖编译时优化。</li>
<li>这使得 C++ 中的虚函数与基于模板的方法相比,对于性能关键型代码而言,是一种“代价高昂”的替代方案。</li>

</ul></li>

</ul>

</aside>
<ul>
<li><b><b>后期绑定:</b></b> 函数调用在运行时通过 vtable 解析。
<ul>
<li><span class="underline">示例(代价值高的替代方法):</span></li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span><span style="color: #c678dd;">()</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">virtual</span> ~<span style="color: #c678dd;">Base</span><span style="color: #c678dd;">()</span> = <span style="color: #51afef;">default</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #ECBE7B;">Base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">override</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">... implementation ...</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
<ul>
<li><b><b>运行时开销:</b></b>
<ul>
<li>间接寻址</li>
<li>无法内联</li>

</ul></li>
<li><b><b>类似于 Java 界面:</b></b></li>

</ul>
</section>
<section id="slide-9-2-2">
<h4 id="9-2-2"><span class="section-number-4">9.2.2.</span> 为什么 C++ 选择编译时多态性</h4>
<aside class="notes">
<p>
this makes c++ code fast
deterministic
but cause JIT come in, it might jitter, first slow
fast then still have GC
easier analysis
</p>
<ul>
<li><b><b>性能敏感性:</b></b> 在像高性能解析(如在 simdjson 中)这样的场景中,每个额外的周期都很重要。</li>
<li><b><b>确定性的开销:</b></b> 通过模板/CRTP,性能特征在编译时是已知的——没有运行时分派的隐藏成本。</li>
<li><b><b>与 Java 的对比:</b></b>
<ul>
<li>Java 的 JIT 可以在运行时优化掉一些虚调用开销,但 C++ 必须在编译期间解析所有内容,因此必须 使用产生零开销抽象的技术。</li>

</ul></li>

</ul>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Java</th>
<th scope="col" class="org-left">C++</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">• Runtime method dispatch via JIT</td>
<td class="org-left">• Compile-time resolution via templates</td>
</tr>

<tr>
<td class="org-left">• Variable latency due to GC</td>
<td class="org-left">• No GC = predictable latency</td>
</tr>

<tr>
<td class="org-left">• Performance changes during execution</td>
<td class="org-left">• Performance known at compile time</td>
</tr>

<tr>
<td class="org-left">• Requires &ldquo;warm up&rdquo; for optimization</td>
<td class="org-left">• Consistent from first call</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-9-3">
<h3 id="9-3"><span class="section-number-3">9.3.</span> 内联函数和编译时内联</h3>
<aside class="notes">
<p>
they did inlining to help the compiler get optimal code
</p>

</aside>
<ul>
<li><b><b>技术:</b></b> 函数标有 `simdjson_inline` 以鼓励内联。</li>
<li><b><b>为什么?:</b></b> 内联消除了小型,常用函数的函数调用开销。</li>
<li><b><b>来自 simdjson 的示例:</b></b></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #51afef; font-weight: bold;">#elif</span> <span style="color: #51afef; font-weight: bold;">defined</span><span style="color: #51afef;">(</span><span style="color: #a9a1e1;">__GNUC__</span><span style="color: #51afef;">)</span> &amp;&amp; <span style="color: #51afef; font-weight: bold;">!</span><span style="color: #51afef; font-weight: bold;">defined</span><span style="color: #51afef;">(</span><span style="color: #a9a1e1;">__OPTIMIZE__</span><span style="color: #51afef;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">If optimizations are disabled, forcing inlining can lead to significant</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">code bloat and high compile times. Don't use simdjson_really_inline for</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unoptimized builds.</span>
<span style="color: #3dea43364a63;"> </span><span style="color: #51afef; font-weight: bold;"> #define</span> <span style="color: #dcaeea;">simdjson_inline</span> <span style="color: #51afef;">inline</span>
<span style="color: #51afef; font-weight: bold;">#else</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded bitwise OR operator</span>
simdjson_inline <span style="color: #ECBE7B;">Child</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> _mm256_or_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<ul>
<li><b><b>注意:</b></b> 在所有小型操作(例如,算术,按位运算符)上使用内联可确保最大性能。</li>

</ul>
</section>
<section id="slide-9-4">
<h3 id="9-4"><span class="section-number-3">9.4.</span> simdjson 中的 C++ 强制转换:性能注意事项</h3>
<aside class="notes">
<p>
here we talk about the casting they use
they only use static_cast and reintepret_cast which is also another
0 cost compile time casting
while the other 2 are runtime checked
</p>

</aside>
<ul>
<li>在高性能 C++ 代码中,使用正确的强制转换对于安全性和速度至关重要。</li>
<li>C++ 提供了几个强制转换运算符:
<ul>
<li><b><b>static_cast</b></b>: 编译时转换。</li>
<li><b><b>reinterpret_cast</b></b>: 低级,指针和位重新解释。</li>
<li><b><b>const_cast</b></b>: 删除 constness。</li>
<li><b><b>dynamic_cast</b></b>: 运行时检查的强制转换(带有 RTTI)。</li>

</ul></li>

</ul>
</section>
<section id="slide-9-4-1">
<h4 id="9-4-1"><span class="section-number-4">9.4.1.</span> CRTP 效率的 static_cast</h4>
<aside class="notes">
<p>
for example this static cast is used to make sure the other type is the same
</p>

</aside>
<ul>
<li>在编译时已知,确保零成本抽象。</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">Child</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">value</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded compound assignment using CRTP</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">Child</span>&amp; <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">this_cast</span> = <span style="color: #51afef;">static_cast</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">Child</span>*<span style="color: #98be65;">&gt;(</span><span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> _this_cast =_ this_cast | other;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> *this_cast;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
<ul>
<li><b><b>注意:</b></b>
<ul>
<li>`static_cast&lt;Child*&gt;(this)` 将基类指针转换为派生类型。</li>

</ul></li>

</ul>
</section>
<section id="slide-9-4-2">
<h4 id="9-4-2"><span class="section-number-4">9.4.2.</span> SIMD 内存操作的 reinterpret_cast</h4>
<aside class="notes">
<p>
convert array into 256 byte for simd use
</p>
<ul>
<li><b><b>为什么?:</b></b> 使用内在函数(例如 AVX2)时,您需要将数据视为特殊类型(如 `__m256i`),并且 reinterpret_cast 在不增加额外开销 的情况下执行此操作。</li>

</ul>

</aside>
<ul>
<li>将原始内存(例如字节数组)重新解释为 SIMD 寄存器类型。</li>
<li>无法对类型检查进行静态强制转换</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">static</span> simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">T</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">load</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">T</span> <span style="color: #dcaeea;">values</span><span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">32</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> _mm256_loadu_si256<span style="color: #c678dd;">(</span><span style="color: #51afef;">reinterpret_cast</span><span style="color: #98be65;">&lt;</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">__m256i</span> *<span style="color: #98be65;">&gt;(</span>values<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>
</pre>
</div>
<ul>
<li><b><b>注意:</b></b>
<ul>
<li>这些 reinterpret_cast 允许编译器生成有效的 SIMD 加载/存储指令。</li>
<li>它们不会产生运行时成本,因为它们是在编译期间解析的。</li>

</ul></li>

</ul>
</section>
<section id="slide-9-4-3">
<h4 id="9-4-3"><span class="section-number-4">9.4.3.</span> 为什么不使用 dynamic_cast 或 const_cast?</h4>
<ul>
<li><b><b>dynamic_cast:</b></b>
<ul>
<li>执行运行时类型检查并产生额外的开销。</li>

</ul></li>
<li><b><b>const_cast:</b></b>
<ul>
<li>const -&gt; other typr</li>

</ul></li>

</ul>
</section>
<section id="slide-9-4-4">
<h4 id="9-4-4"><span class="section-number-4">9.4.4.</span> simdjson 中的强制转换摘要</h4>
<ul>
<li><b><b>static_cast:</b></b>
<ul>
<li>用于编译时转换(例如,CRTP 基类到派生类指针转换)。</li>
<li>零成本和类型安全。</li>

</ul></li>
<li><b><b>reinterpret_cast:</b></b>
<ul>
<li>用于指针重新解释(例如,将字节数组转换为 SIMD 寄存器指针)。</li>
<li>与低级别内在函数接口的必要组件。</li>

</ul></li>
<li><b><b>避免的强制转换:</b></b>
<ul>
<li><b><b>dynamic_cast</b></b> 和 <b><b>const_cast</b></b> 不用于性能关键部分,以防止不必要的运行时开销。</li>

</ul></li>

</ul>
</section>
<section id="slide-9-5">
<h3 id="9-5"><span class="section-number-3">9.5.</span> 为什么错误代码优于异常</h3>
<aside class="notes">
<p>
error code does not unwind stack like how except does
more linera flow
predictable branching
</p>

</aside>
<ul>
<li>零成本错误处理:无堆栈展开或 EH 表</li>
<li>更好的编译器优化:线性控制流</li>
<li>可预测的分支模式:CPU 管道友好</li>
<li>更小的代码大小:无异常处理元数据</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++">simdjson_warn_unused <span style="color: #ECBE7B;">error_code</span> <span style="color: #c678dd;">minify</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint8_t</span> <span style="color: #dcaeea;">_buf</span>, <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">len</span>, <span style="color: #ECBE7B;">uint8_t_</span> <span style="color: #dcaeea;">dst</span>, <span style="color: #ECBE7B;">size_t</span> &amp;<span style="color: #dcaeea;">dst_len</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">noexcept</span> <span style="color: #51afef;">final</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> set_best<span style="color: #c678dd;">()</span>-&gt;minify<span style="color: #c678dd;">(</span>buf, len, dst, dst_len<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-9-5-1">
<h4 id="9-5-1"><span class="section-number-4">9.5.1.</span> 程序集比较:错误代码路径(simdjson 样式)</h4>
<aside class="notes">
<p>
error path
</p>

</aside>
<div class="org-src-container">

<pre class="src src-asm"><span style="color: #c678dd;">check_ascii</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">vptest</span> <span style="color: #dcaeea;">%ymm0</span>, <span style="color: #dcaeea;">%ymm1</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">jne</span> .error        <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Single conditional branch</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... normal path ...</span>
<span style="color: #c678dd;">.error</span>:             <span style="color: #5B6268;">; </span><span style="color: #5B6268;">simd branchless way if possible</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">mov</span> eax, <span style="color: #da8548; font-weight: bold;">1</span>        <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Set error code</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">ret</span>
</pre>
</div>
</section>
<section id="slide-9-5-2">
<h4 id="9-5-2"><span class="section-number-4">9.5.2.</span> 程序集比较:异常路径</h4>
<aside class="notes">
<p>
except path show the stack trace there
</p>

</aside>
<div class="org-src-container">

<pre class="src src-asm"><span style="color: #c678dd;">check_ascii</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">vptest</span> <span style="color: #dcaeea;">%ymm0</span>, <span style="color: #dcaeea;">%ymm1</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">jne</span> .exception
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... normal path ...</span>
<span style="color: #c678dd;">.exception</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">call</span> __cxa_allocate_exception  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Heavy EH machinery</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... stack unwinding setup ...</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">- Exception table lookups</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">- Destructor calls</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">- Catch handler matching</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">- Stack unwinding</span>
</pre>
</div>
</section>
<section id="slide-9-5-3">
<h4 id="9-5-3"><span class="section-number-4">9.5.3.</span> 主要性能因素</h4>
<ol>
<li><b><b>无 EH 表开销</b></b>
<ul>
<li>异常处理需要 RTTI 和堆栈展开表</li>

</ul></li>
<li><b><b>CPU 分支预测</b></b>
<ul>
<li>错误代码使用简单的条件分支
<ul>
<li>异常创建不可预测的控制流</li>

</ul></li>

</ul></li>
<li><b><b>内联友好</b></b>
<ul>
<li>错误返回路径不会抑制函数内联</li>
<li>对于 SIMD 优化至关重要</li>

</ul></li>

</ol>
</section>
<section id="slide-9-6">
<h3 id="9-6"><span class="section-number-3">9.6.</span> 内存对齐和填充</h3>
<aside class="notes">
<ul>
<li>we working with SBE should know about this
i&rsquo;ll skip its just that aligned access is faster than non aligned access</li>
<li>simdjson uses types such as padded_string and padded_string_view to guarantee ample padding.</li>

</ul>

</aside>
<ul>
<li>正确的内存对齐(和额外的填充)对于 SIMD 操作至关重要;未对齐的访问会严重损害性能。</li>

</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a9a1e1;">simdjson</span>::<span style="color: #ECBE7B;">padded_string_view</span> <span style="color: #c678dd;">get_padded_string_view</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">buf</span>, <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">len</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>  <span style="color: #a9a1e1;">simdjson</span>::<span style="color: #ECBE7B;">padded_string</span> &amp;<span style="color: #dcaeea;">jsonbuffer</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span>need_allocation<span style="color: #98be65;">(</span>buf, len<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unlikely case</span>
<span style="color: #3dea43364a63;"> </span>   jsonbuffer = <span style="color: #a9a1e1;">simdjson</span>::padded_string<span style="color: #98be65;">(</span>buf, len<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> jsonbuffer;
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span> <span style="color: #51afef;">else</span> <span style="color: #c678dd;">{</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">no allocation needed (most common)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">simdjson</span>::padded_string_view<span style="color: #98be65;">(</span>buf, len, len + <span style="color: #a9a1e1;">simdjson</span>::<span style="color: #a9a1e1;">SIMDJSON_PADDING</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-9-7">
<h3 id="9-7"><span class="section-number-3">9.7.</span> 循环展开和向量化处理</h3>
<aside class="notes">
<p>
loop unrolling is debatable sometimes it helps
sometimes is bad
in this case it helps because we are using fixed 512 byte sizes
do not unroll things if you dont know the size
it is harder for complier to optimize that
</p>

</aside>
<ul>
<li><b><b>关键思路:</b></b> 展开循环以手动执行更多操作</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_optimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get total number of set bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">count</span> = __builtin_popcountll<span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">next_base</span> = output + count;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Process 8 bits at a time unconditionally</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Extract next 8 set bit positions, even if we don't have 8 bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear lowest set bit (blsr instruction)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
</pre>
</div>
</section>
<section id="slide-9-8">
<h3 id="9-8"><span class="section-number-3">9.8.</span> 编译器指令和特殊构建标志</h3>
<ul>
<li>编译器标志(例如,-O3 或 -march=native)和特定宏是释放峰值性能的关键。</li>

</ul>
</section>
<section id="slide-9-9">
<h3 id="9-9"><span class="section-number-3">9.9.</span> C++优化摘要</h3>
<ul>
<li>零成本抽象</li>
<li>内联函数和强制转换</li>
<li>异常的错误代码</li>
<li>内存和循环优化</li>

</ul>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> 谢谢您</h2>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/search/search.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'slide',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
