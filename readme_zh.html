<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Parsing Gigabytes of JSON per Second 每秒解析千兆字节的 JSON</title>
<meta name="author" content="Wong Ding Feng Wong Ding Feng"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Parsing Gigabytes of JSON per Second 每秒解析千兆字节的 JSON</h1><h2 class="author">Wong Ding Feng Wong Ding Feng</h2><p class="date">Created: 2025-02-03 Mon 00:56</p>
</section>
<section id="table-of-contents-section">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#/slide-1">1. Objectives 目标</a></li>
<li><a href="#/slide-2">2. Problem 问题</a></li>
<li><a href="#/slide-3">3. Ideas on how to do it fast?  如何快速实现？</a></li>
<li><a href="#/slide-4">4. challenges 挑战</a></li>
<li><a href="#/slide-5">5. About SIMD  关于 SIMD</a></li>
<li><a href="#/slide-6">6. Simdjson Implementation  Simdjson 实现</a></li>
<li><a href="#/slide-7">7. Stage 1: Structural and Pseudo Structural Index Construction  阶段 1：结构和伪结构索引构建</a></li>
<li><a href="#/slide-8">8. Actual c++ code implementation and optimization tricks in the code base  代码库中的实际 C++ 实现及优化技巧</a></li>
<li><a href="#/slide-9">9. Thank you  谢谢大家</a></li>
</ul>
</div>
</div>
</section>
<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Objectives 目标</h2>
<aside class="notes">
<p>
Too many things to talk about
pick and choose some
</p>

</aside>
<ul>
<li>Describe the real problem with JSON  描述 JSON 真正的问题
<ul>
<li>Techniques and strategies to make it fast    提高速度的技术和策略</li>

</ul></li>
<li>Simple primer on bitwise operations and simd   位运算和 SIMD 简介</li>
<li>simdjson architecture   simdjson 架构</li>
<li>How this is used to make simdjson   这如何用于构建 simdjson</li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Problem 问题</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> How fast is your hardware  你的硬件有多快</h3>
<aside class="notes">
<p>
One core on your computer can actually read and write around 3GB of data per second
</p>

</aside>

<p>
CPU: AMD Eng Sample: 100-000000534-40_Y: 4.6 GHz CPU：AMD Eng 样本：100-000000534-40_Y：4.6 GHz
Network: 1Gb~100MB/s, 10Gb~1000MB/s 网络：1Gb 约 100MB/s, 10Gb 约 1000MB/s
</p>

<p>
One core can read direct text at this speed: 单核可以以此速度直接读取文本:
</p>
<div class="org-src-container">

<pre class="src src-text">Testing dd read:
1280+0 records in
1280+0 records out
10737418240 bytes (11 GB, 10 GiB) copied, 3.88076 s, 2.8 GB/s
</pre>
</div>
</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Why is json interesting?  为什么 JSON 有趣？</h3>
<ul>
<li>most data is in json   大多数数据都是 JSON 格式</li>
<li>basically double the speed means you can parse 2x as much data   基本上速度翻倍意味着你可以解析 2 倍的数据
<ul>
<li>duplicating hardware for free     免费获得硬件性能的倍增</li>

</ul></li>

</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">parser</th>
<th scope="col" class="org-right">Skylake</th>
<th scope="col" class="org-right">Cannon Lake</th>
<th scope="col" class="org-left">speed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">simdjson</td>
<td class="org-right">1.4</td>
<td class="org-right">1.3</td>
<td class="org-left">fast</td>
</tr>

<tr>
<td class="org-left">RapidJSON</td>
<td class="org-right">0.56</td>
<td class="org-right">0.44</td>
<td class="org-left">slow</td>
</tr>

<tr>
<td class="org-left">sajson</td>
<td class="org-right">0.93</td>
<td class="org-right">0.84</td>
<td class="org-left">normal</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> Why you should be interested  为什么你应该感兴趣</h3>
<ul>
<li>configurable, increase speed   可配置性，可提升速度</li>

</ul>


<div id="orgef0b9a3" class="figure">
<p><img src="https://arxiv.org/html/1902.08318v7/x1.png" alt="x1.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Against others  与其他方法对比</h3>

<div id="org23274a1" class="figure">
<p><img src="https://arxiv.org/html/1902.08318v7/x3.png" alt="x3.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-2-5">
<h3 id="2-5"><span class="section-number-3">2.5.</span> On demand json  按需 JSON</h3>

<div id="org2a81426" class="figure">
<p><img src="https://arxiv.org/html/2312.17149v3/x1.png" alt="x1.png" style="background-color: white;" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Ideas on how to do it fast?  如何快速实现？</h2>
<aside class="notes">
<p>
Suppose we think we have already written the fastest possible cpu parser in the world, what other ways can we speed it up?
</p>

</aside>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> strategies  策略</h3>
<ul>
<li>depends on the usage pattern   取决于使用模式</li>

</ul>
</section>
<section id="slide-3-1-1">
<h4 id="3-1-1"><span class="section-number-4">3.1.1.</span> Query intensive  查询密集型</h4>
<ul>
<li>Create a database (ElasticSearch, MongoDB, PostgresSQL)   创建数据库（ElasticSearch、MongoDB、PostgresSQL）
<ul>
<li>create a KV store     创建键值存储</li>
<li>load once and query it     一次加载，多次查询</li>

</ul></li>

</ul>
</section>
<section id="slide-3-1-2">
<h4 id="3-1-2"><span class="section-number-4">3.1.2.</span> Selective parsing  选择性解析</h4>
<aside class="notes">
<p>
The other opposite end is no parsing,
Skip the parsing as parsing takes time, NoDB, do a grep search and jump around detecting some structures and patterns in the data
There was a research paper talking about using JIT and speeding up the json query like a compiler
Mison is another implementation that uses simd to find important character locations like braces [] " : and the authors of simdjson learnt lots from them.
</p>

</aside>
<ul>
<li>Selective parsing   选择性解析
<ul>
<li>NoDB     无数据库
<ul>
<li>query the data without parsing it, without loading into a DB       在不解析、不加载到数据库的情况下查询数据</li>
<li>like grep       类似于 grep</li>

</ul></li>
<li>JIT techniques       JIT 技术
<ul>
<li>find patterns and repetitive structures, compile the code for the specific query       查找模式和重复结构，为特定查询编译代码</li>
<li>like a compiler       类似于编译器</li>

</ul></li>
<li><b>Mison</b> (by Microsoft)       *Mison*（由微软开发）
<ul>
<li>selective parsing, jump directly to the field you want       选择性解析，直接跳转到所需字段</li>
<li>use SIMD to find structural important characters like "       使用 SIMD 查找结构上重要的字符，例如引号</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> What is fair game?  什么是公平的规则？</h3>
<aside class="notes">
<p>
So there are many json implementations out there and to measure performance, we need to properly define what json means.
</p>

<p>
Most faster json parser implementations play cheat by just assuming the input is already valid.
</p>

<p>
assuming strings are only ascii when json RFC said UTF-8, dont validate numbers, selectively parsing.
</p>

<p>
simdjson is a complete parser following Json RFC standards, fully validating the input yet being faster than all of them. assuming input is correct is dangerous because it just is wrong input and wrong output
</p>

</aside>
<ul>
<li>Types of json parsing   JSON 解析的类型
<ul>
<li>Non-validating json parser     非验证型 JSON 解析器
<ul>
<li>assume the input is valid       假设输入是有效的</li>
<li>easier       更简单</li>
<li>most selective parsing is non-validating       大多数选择性解析都不验证</li>

</ul></li>
<li>Validating json parser       验证型 JSON 解析器
<ul>
<li>check the input is valid       检查输入是否有效</li>
<li>no assumptions or malformed input       无任何假设，接受格式正确的输入
<ul>
<li>security risk         安全风险</li>
<li>its just wrong number or string being parsed         解析出来的数字或字符串可能错误</li>

</ul></li>
<li>harder more complex         更难、更复杂</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Proper definition of JSON  JSON 的正确定义</h3>
<aside class="notes">
<p>
This is the real EBNF grammar for json, its kinda complex so i wrote a simplified version below
</p>

</aside>

<div class="org-src-container">

<pre class="src src-ebnf">/* JSON EBNF Grammar Specification */

/* Root JSON structure */
<span style="color: #dcaeea;">json</span> = ws , (object | array) , ws <span style="color: #5B6268;">;</span>

/* Objects */
<span style="color: #dcaeea;">object</span> = <span style="color: #98be65;">"{"</span> , ws , [ members ] , ws , <span style="color: #98be65;">"}"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">members</span> = pair , { <span style="color: #98be65;">","</span> , ws , pair } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">pair</span> = string , ws , <span style="color: #98be65;">":"</span> , ws , value <span style="color: #5B6268;">;</span>

/* Arrays */
<span style="color: #dcaeea;">array</span> = <span style="color: #98be65;">"["</span> , ws , [ elements ] , ws , <span style="color: #98be65;">"]"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">elements</span> = value , { <span style="color: #98be65;">","</span> , ws , value } <span style="color: #5B6268;">;</span>

/* Values */
<span style="color: #dcaeea;">value</span> = string | number | object | array | <span style="color: #98be65;">"true"</span> | <span style="color: #98be65;">"false"</span> | <span style="color: #98be65;">"null"</span> <span style="color: #5B6268;">;</span>

/* Strings */
<span style="color: #dcaeea;">string</span> = '<span style="color: #98be65;">"' , { char | escape } , '"</span>' <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">char</span> = ? any Unicode character except <span style="color: #98be65;">" or \ or control characters ? ;</span>
<span style="color: #98be65;">escape = "</span>\" , ('<span style="color: #98be65;">"' | "</span>\" | <span style="color: #98be65;">"/"</span> | <span style="color: #98be65;">"b"</span> | <span style="color: #98be65;">"f"</span> | <span style="color: #98be65;">"n"</span> | <span style="color: #98be65;">"r"</span> | <span style="color: #98be65;">"t"</span> | unicode) <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">unicode</span> = <span style="color: #98be65;">"u"</span> , hexdigit , hexdigit , hexdigit , hexdigit <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">hexdigit</span> = digit | <span style="color: #98be65;">"A"</span> | <span style="color: #98be65;">"B"</span> | <span style="color: #98be65;">"C"</span> | <span style="color: #98be65;">"D"</span> | <span style="color: #98be65;">"E"</span> | <span style="color: #98be65;">"F"</span> | <span style="color: #98be65;">"a"</span> | <span style="color: #98be65;">"b"</span> | <span style="color: #98be65;">"c"</span> | <span style="color: #98be65;">"d"</span> | <span style="color: #98be65;">"e"</span> | <span style="color: #98be65;">"f"</span> <span style="color: #5B6268;">;</span>

/* Numbers */
<span style="color: #dcaeea;">number</span> = [ <span style="color: #98be65;">"-"</span> ] , (zero | integer) , [ fraction ] , [ exponent ] <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">integer</span> = nonzero , { digit } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">nonzero</span> = <span style="color: #98be65;">"1"</span> | <span style="color: #98be65;">"2"</span> | <span style="color: #98be65;">"3"</span> | <span style="color: #98be65;">"4"</span> | <span style="color: #98be65;">"5"</span> | <span style="color: #98be65;">"6"</span> | <span style="color: #98be65;">"7"</span> | <span style="color: #98be65;">"8"</span> | <span style="color: #98be65;">"9"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">digit</span> = <span style="color: #98be65;">"0"</span> | nonzero <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">zero</span> = <span style="color: #98be65;">"0"</span> <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">fraction</span> = <span style="color: #98be65;">"."</span> , digit , { digit } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">exponent</span> = (<span style="color: #98be65;">"E"</span> | <span style="color: #98be65;">"e"</span>) , [ <span style="color: #98be65;">"+"</span> | <span style="color: #98be65;">"-"</span> ] , digit , { digit } <span style="color: #5B6268;">;</span>

/* Whitespace */
<span style="color: #dcaeea;">ws</span> = { whitespace } <span style="color: #5B6268;">;</span>
<span style="color: #dcaeea;">whitespace</span> = <span style="color: #98be65;">" "</span> | <span style="color: #98be65;">"\t"</span> | <span style="color: #98be65;">"\n"</span> | <span style="color: #98be65;">"\r"</span> <span style="color: #5B6268;">;</span>

/* Comments and Explanation */
</pre>
</div>
</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> My reduced definition of JSON  我简化的 JSON 定义</h3>
<aside class="notes">
<p>
A json value is just made up of 2 value types
primitive value and container value
</p>

<p>
primitive is just like all the java primitives that we know of, boolean string number null
</p>

<p>
container types only has 2 types array and objects
</p>

<p>
arrays can contain any json value
objects contain {string: json_value}
</p>

</aside>

<div class="org-src-container">

<pre class="src src-ebnf">json_value ::= primitive_value | container_value

primitive_value ::= boolean | string | number | null

boolean ::= <span style="color: #98be65;">"true"</span> | <span style="color: #98be65;">"false"</span>

string ::= <span style="color: #98be65;">" utf8_char* "</span>
utf8_char ::= ascii_char | unicode_char

number ::= integer | decimal | scientific
integer ::= [<span style="color: #98be65;">"+"</span> | <span style="color: #98be65;">"-"</span>] digit+
decimal ::= integer <span style="color: #98be65;">"."</span> digit+
scientific ::= decimal <span style="color: #98be65;">"e"</span> [<span style="color: #98be65;">"+"</span>|<span style="color: #98be65;">"-"</span>] digit+
digit ::= <span style="color: #da8548; font-weight: bold;">0</span> | <span style="color: #da8548; font-weight: bold;">1</span> | <span style="color: #da8548; font-weight: bold;">2</span> | <span style="color: #da8548; font-weight: bold;">3</span> | <span style="color: #da8548; font-weight: bold;">4</span> | <span style="color: #da8548; font-weight: bold;">5</span> | <span style="color: #da8548; font-weight: bold;">6</span> | <span style="color: #da8548; font-weight: bold;">7</span> | <span style="color: #da8548; font-weight: bold;">8</span> | <span style="color: #da8548; font-weight: bold;">9</span>

null ::= <span style="color: #98be65;">"null"</span>

container_value ::= object | array

object ::= <span style="color: #98be65;">"{"</span> string:json_value, string:json_value <span style="color: #98be65;">"}"</span>

array ::= <span style="color: #98be65;">"["</span> json_value, json_value <span style="color: #98be65;">"]"</span>

(* Notes:
<span style="color: #3dea43364a63;"> </span>  - Integer limits: [-2^53+1 to <span style="color: #da8548; font-weight: bold;">2</span>^53-1] for safe integers
<span style="color: #3dea43364a63;"> </span>  - Scientific notation limit: approximately &#177;2^<span style="color: #da8548; font-weight: bold;">1024</span>
<span style="color: #3dea43364a63;"> </span>  - NaN and Infinity are not valid JSON numbers
<span style="color: #3dea43364a63;"> </span>  - Strings must be UTF-8 encoded
*)
</pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Strongly define: bool, string, number, null, object and array  强类型定义：bool, string, number, null, object 和 array</h3>
<aside class="notes">
<p>
boolean, true, false and null are trivial
</p>

<p>
So first we start with the simplest sounding one of all, number, just integers right?, decimal perhaps? easy!
</p>

</aside>
</section>
<section id="slide-3-5-1">
<h4 id="3-5-1"><span class="section-number-4">3.5.1.</span> Number limits and Integers  数值范围与整数</h4>
<aside class="notes">
<p>
Lets take a look at limits.
Theres no strict definition for the limit of numbers, most use (2^53 - 1) because of the floating point representation
the authors of SIMDjson prefer 2^63 - 1
the first special case we have to deal with is negative numbers, we cant only detect 0 - 9, we have to detect - as well.
</p>

</aside>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">1. Integer Limits</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">INTEGER_EXAMPLES</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Maximum safe integer in JavaScript (2^53 - 1)</span>
<span style="color: #3dea43364a63;"> </span>   max_safe_integer: <span style="color: #da8548; font-weight: bold;">9007199254740991</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Minimum safe integer in JavaScript (-(2^53 - 1))</span>
<span style="color: #3dea43364a63;"> </span>   min_safe_integer: -<span style="color: #da8548; font-weight: bold;">9007199254740991</span>,
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Zero representations</span>
<span style="color: #3dea43364a63;"> </span>   zero: <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   negative_zero: -<span style="color: #da8548; font-weight: bold;">0</span>,  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">JSON preserves negative zero</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Common boundary values</span>
<span style="color: #3dea43364a63;"> </span>   max_32bit_int: <span style="color: #da8548; font-weight: bold;">2147483647</span>,
<span style="color: #3dea43364a63;"> </span>   min_32bit_int: -<span style="color: #da8548; font-weight: bold;">2147483648</span>,
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Integer examples</span>
<span style="color: #3dea43364a63;"> </span>   positive: <span style="color: #da8548; font-weight: bold;">42</span>,
<span style="color: #3dea43364a63;"> </span>   negative: -<span style="color: #da8548; font-weight: bold;">42</span>
};
</pre>
</div>
</section>
<section id="slide-3-5-2">
<h4 id="3-5-2"><span class="section-number-4">3.5.2.</span> Floats and Scientific notation  浮点数和科学计数法</h4>
<aside class="notes">
<p>
Floats, you see the e-308.
below you can see that both E and e are valid
some + and some - exponents
some without the + and - signs
</p>

<p>
what about the special case of 0.0e0!? how do we handle that?
these are all the details your validator needs to check for before declaring that this is a valid input
</p>

</aside>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">2. Floating Point Examples</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">FLOAT_EXAMPLES</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Precision examples (up to 15-17 significant digits)</span>
<span style="color: #3dea43364a63;"> </span>   high_precision: <span style="color: #da8548; font-weight: bold;">1.234567890123456</span>,
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Edge cases</span>
<span style="color: #3dea43364a63;"> </span>   very_small_positive: <span style="color: #da8548; font-weight: bold;">2</span>.2250738585072014e-<span style="color: #da8548; font-weight: bold;">308</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Near smallest possible double</span>
<span style="color: #3dea43364a63;"> </span>   very_large_positive: <span style="color: #da8548; font-weight: bold;">1</span>.7976931348623157e+<span style="color: #da8548; font-weight: bold;">308</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Near largest possible double</span>
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">3. Scientific Notation Examples</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">SCIENTIFIC_NOTATION</span> = {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Positive exponents</span>
<span style="color: #3dea43364a63;"> </span>   large_scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e+<span style="color: #da8548; font-weight: bold;">11</span>,
<span style="color: #3dea43364a63;"> </span>   very_large: <span style="color: #da8548; font-weight: bold;">1</span>.23E+<span style="color: #da8548; font-weight: bold;">308</span>,  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: Both 'e' and 'E' are valid</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Negative exponents</span>
<span style="color: #3dea43364a63;"> </span>   small_scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e-<span style="color: #da8548; font-weight: bold;">11</span>,
<span style="color: #3dea43364a63;"> </span>   very_small: <span style="color: #da8548; font-weight: bold;">1</span>.23E-<span style="color: #da8548; font-weight: bold;">308</span>,
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Zero with exponent</span>
<span style="color: #3dea43364a63;"> </span>   zero_scientific: <span style="color: #da8548; font-weight: bold;">0</span>.0e0,
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Various representations</span>
<span style="color: #3dea43364a63;"> </span>   alternative_forms: {
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   standard: <span style="color: #da8548; font-weight: bold;">1230000000</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   scientific: <span style="color: #da8548; font-weight: bold;">1</span>.23e9,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   another_form: 123e7
<span style="color: #3dea43364a63;"> </span>   }
};


</pre>
</div>
</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> String: handle escaped quotes and UTF-8  字符串：处理转义引号和 UTF-8</h3>
<aside class="notes">
<p>
next we have string, many implementations just assume ascii
</p>

<p>
json RFC says it must be UTF-8
</p>

<p>
the last important thing to take note of is escaped \", we need to detect them properly to get the correct json, everything is done in simd.
</p>

</aside>
<ul>
<li>some lazy parsers assume ascii for simplicity   一些懒惰的解析器为了简单假设仅为 ASCII
<ul>
<li>128 possibilities, 8 bits only     只有 128 种可能，8 位</li>
<li>assume that input does not have japanese or chinese or weird characters     假设输入中不包含日文、中文或奇怪字符</li>

</ul></li>
<li>RFC standard says strings are UTF-8     RFC 标准规定字符串必须为 UTF-8</li>
<li>escaped double quotes &ldquo;Tom said: \&rdquo;hello\&ldquo;.&rdquo;     转义双引号 &ldquo;Tom said: \&rdquo;hello\&ldquo;.&rdquo;
<ul>
<li>Tom said: &ldquo;hello&rdquo;.       Tom 说：“hello”。</li>
<li>number of &rsquo;\&rsquo;       反斜杠的数量
<ul>
<li>odd -&gt; escaped, &ldquo;\&rdquo;&ldquo; -&gt; &rdquo;       奇数个 -&gt; 被转义，&ldquo;\&rdquo;&ldquo; 代表 &rdquo;</li>
<li>even -&gt; not escaped, &ldquo;\\&rdquo; -&gt; &ldquo;\&rdquo;&ldquo;       偶数个 -&gt; 未转义，&rdquo;\\&ldquo; 代表 &rdquo;\"</li>

</ul></li>

</ul></li>
<li>outside of ",there can only be 4 types of white space     在引号之外，只允许 4 种空白字符
<ul>
<li>&ldquo; &rdquo; | &ldquo;\t&rdquo; | &ldquo;\r&rdquo; | &ldquo;\n&rdquo;       &ldquo; &rdquo; | &ldquo;\t&rdquo; | &ldquo;\r&rdquo; | &ldquo;\n&rdquo;</li>

</ul></li>

</ul>
</section>
<section id="slide-3-6-1">
<h4 id="3-6-1"><span class="section-number-4">3.6.1.</span> ASCII code  ASCII 编码</h4>
<aside class="notes">
<p>
This is just simply the ascii code table, quite sure we are all very familiar with it 0x30 - 0x39 is digits 0-9 lets move on
</p>

</aside>
<ul>
<li>code ponits 0x00 - 0xEF 127 possibilities     代码点 0x00 - 0xEF，共 127 种可能</li>

</ul>

<div id="org2ad829a" class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/USASCII_code_chart.svg/1280px-USASCII_code_chart.svg.png" alt="1280px-USASCII_code_chart.svg.png" style="background-color: white;" />
</p>
</div>
</section>
<section id="slide-3-6-2">
<h4 id="3-6-2"><span class="section-number-4">3.6.2.</span> UTF-8  UTF-8</h4>
<aside class="notes">
<p>
if it starts with the first bit being 0, it is ASCII
else if it is 1, it must conform to UTF-8 standards
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data

Two bytes:
110xxxxx 10xxxxxx           (values 128-2047)
First byte starts with 110

Three bytes:
1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
First byte starts with 1110

Four bytes:
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
First byte starts with 11110
</pre>
</div>
<ul>
<li>normally outside of strings, no bytes start with 1 in front.     通常在字符串外，没有字节以 1 开头。</li>

</ul>
</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Summary of requirements  需求总结</h3>
<ul>
<li>numbers     数字
<ul>
<li>negative       负数</li>
<li>floats       浮点数</li>

</ul></li>
<li>string       字符串
<ul>
<li>utf-8       UTF-8</li>
<li>escaped quotes \&ldquo;       转义引号 \&rdquo;</li>

</ul></li>
<li>Rest of structure well formed     其它结构必须格式正确
<ul>
<li>valid whitespace       有效空白字符</li>
<li>valid bracket {}, []       有效的括号 {}, []</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> challenges 挑战</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> writing a parser for it  为它编写解析器</h3>
<aside class="notes">
<p>
Im not sure how many of us here has written a recursive descent parser but normally
how one would write a parser is that
one would just scan the string from left to right until it can determine what to do with the input
this requires many if else checks to see when to stop, when to look back, when to decide that what I am seeing is an object, string, array &#x2026;
</p>

<p>
the problem is that if statements cause a miss predicted branch, this is very costly to computers
if the branching is very predictable, like taking true all the time, there is no cost, usually the cpu will just
assume the previous branch was taken and follow that, then the cost is 1 cycle
</p>

<p>
if we need to stop and recorrect the branch it will take at least 15 cycles.
</p>

<p>
Can you do it without branches? thats what the SIMDjson team was working on.
</p>

</aside>
<ul>
<li>Recursive Descent type parser     递归下降解析器</li>
<li>Many if else required, is it possible to do it without any branches?     需要许多 if-else，是否可以实现无分支？</li>

</ul>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">peek_token_type</span>(json_str, index):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">char</span> = json_str[index]
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Skip whitespace</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> index &lt; <span style="color: #c678dd;">len</span>(json_str) <span style="color: #51afef;">and</span> is_whitespace(char):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">index</span> += <span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #dcaeea;">char</span> = json_str[index]
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Check data type based on first character</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> char == <span style="color: #98be65;">'{'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'object'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'['</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'array'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'"'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'string'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> is_digit(char):
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'number'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'t'</span> <span style="color: #51afef;">or</span> char == <span style="color: #98be65;">'f'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'boolean'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">elif</span> char == <span style="color: #98be65;">'n'</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">'null'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">else</span>:
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">raise</span> <span style="color: #ECBE7B;">ValueError</span>(f<span style="color: #98be65;">"Invalid JSON character at position </span>{index}<span style="color: #98be65;">: </span>{char}<span style="color: #98be65;">"</span>)
</pre>
</div>
</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Given the challenge, how to do it fast?  在这种挑战下，如何快速实现？</h3>
<aside class="notes">
<p>
mison already implemented some of these but not everything
</p>

</aside>
<ul>
<li>Parallelization, split work across multiple cores.     并行化，将工作分配到多个核心</li>
<li>SIMD, process more than 8 bytes at a time.     SIMD，一次处理超过 8 个字节
<ul>
<li>Branchless code, no if statements. CPU missed branch prediction.       无分支代码，无 if 语句。CPU 分支预测失误时会有额外开销。
<ul>
<li>correct, 0-1 cycles       正常情况，0-1 个周期</li>
<li>branch miss, 20 cycles       分支失误时，约 20 个周期</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> About SIMD  关于 SIMD</h2>
<p>
how does simd fit into all of this?  SIMD 在这一切中扮演什么角色？
</p>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> What is simd  什么是 SIMD</h3>

<div id="org7191c74" class="figure">
<p><img src="https://pep-root6.github.io/docs/analysis/simd.png" alt="simd.png" />
</p>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> SIMD example  SIMD 示例</h3>
<pre class="example" id="org6493502">
Adding 4 numbers simultaneously:

Scalar:
A: [5] + [3] = [8]     Step 1
B: [7] + [2] = [9]     Step 2
C: [4] + [6] = [10]    Step 3
D: [1] + [8] = [9]     Step 4

SIMD:
[5|7|4|1] +
[3|2|6|8] =   Step 1
[8|9|10|9]    Done!
</pre>
</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> CPU  CPU</h3>
<div class="org-src-container">

<pre class="src src-text">Year:         2010          2013          2019
Architecture: Westmere  -&gt;  Haswell   -&gt;  Ice Lake
Process:      32nm          22nm          10nm
Vector ISA:   SSE2      -&gt;  AVX2      -&gt;  AVX512
Vec Width:    128-bit       256-bit       512-bit
             (16 bytes)    (32 bytes)    (64 bytes)
</pre>
</div>
<ul>
<li>Streaming SIMD Extensions     流式 SIMD 扩展
<ul>
<li>XMM0-XMM15       XMM0-XMM15</li>

</ul></li>
<li>Advanced Vector Extensions 2     高级向量扩展 2 (AVX2)
<ul>
<li>YMM0-YMM15       YMM0-YMM15</li>

</ul></li>
<li>Advanced Vector Extensions 512     高级向量扩展 512 (AVX-512)
<ul>
<li>ZMM0-ZMM15       ZMM0-ZMM15</li>

</ul></li>

</ul>
</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> SIMD code is not that scary  SIMD 代码并没有那么可怕</h3>
<p>
Westmere uses 128-bit SSE instructions     (_mm_shuffle_epi8)  Westmere 使用 128 位 SSE 指令 (_mm_shuffle_epi8)
Haswell  uses 256-bit AVX2 instructions    (_mm256_shuffle_epi8)  Haswell 使用 256 位 AVX2 指令 (_mm256_shuffle_epi8)
Ice Lake uses 512-bit AVX-512 instructions (_mm512_shuffle_epi8)  Ice Lake 使用 512 位 AVX-512 指令 (_mm512_shuffle_epi8)
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Westmere</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">2</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">3</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Haswell (2 x 256-bit chunks)</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Ice Lake (1 x 512-bit chunk)</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm512_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
</pre>
</div>
</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> When SIMD Shines  SIMD 何时展现优势</h3>
<ul>
<li>Regular, predictable data patterns     规则且可预测的数据模式</li>
<li>Simple mathematical operations     简单的数学运算</li>
<li>Continuous blocks of memory     连续的内存块</li>
<li>Identical operations on multiple data points     对多个数据点执行相同操作</li>
<li>High throughput     高吞吐量</li>

</ul>
<pre class="example" id="org08fab4b">
Perfect for SIMD:
[1|2|3|4] × 2  = [2 |4 |6 |8 ] ✓
[R|G|B|A] + 10 = [R'|G'|B'|A'] ✓
</pre>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> SIMD&rsquo;s Achilles Heel: Branching  SIMD 的致命弱点：分支</h3>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'{'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"object"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'['</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"array"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'"'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"string"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>is_digit<span style="color: #c678dd;">(</span>char_at<span style="color: #c678dd;">)</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"number"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'t'</span> || char_at == <span style="color: #98be65;">'f'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"boolean"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>char_at == <span style="color: #98be65;">'n'</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #98be65;">"null"</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">throw</span> <span style="color: #a9a1e1;">std</span>::invalid_argument<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">"Invalid JSON character at position "</span> +
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::to_string<span style="color: #98be65;">(</span>index<span style="color: #98be65;">)</span> +
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">": "</span> + char_at
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> Arithmetic booleans  算术布尔运算</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 1: Arithmetic with booleans</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">condition</span> = <span style="color: #a9a1e1;">true</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">20</span>;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branched version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>condition<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = a;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = b;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version 1</span>
<span style="color: #3dea43364a63;"> </span>   x = condition * a + <span style="color: #51afef;">(</span><span style="color: #51afef; font-weight: bold;">!</span>condition<span style="color: #51afef;">)</span> * b;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true * 10 + (!true) * 20</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1 * 10 + 0 * 20</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 + 0 = 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version 2</span>
<span style="color: #3dea43364a63;"> </span>   x = b + <span style="color: #51afef;">(</span>a - b<span style="color: #51afef;">)</span> * condition;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 + (10 - 20) * true</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 + (-10) * 1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20 - 10 = 10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
</pre>
</div>
</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> Selection indexing  选择索引</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 2: Tuple indexing</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">condition</span> = <span style="color: #a9a1e1;">true</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">20</span>;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branched version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>condition<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = a;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   x = b;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Branchless version</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">array</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span>, <span style="color: #da8548; font-weight: bold;">2</span><span style="color: #51afef;">&gt;</span> <span style="color: #dcaeea;">values</span> = <span style="color: #51afef;">{</span>b, a<span style="color: #51afef;">}</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: array order is {b, a} to match Python's (b, a)</span>
<span style="color: #3dea43364a63;"> </span>   x = values<span style="color: #51afef;">[</span>condition<span style="color: #51afef;">]</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Step by step:</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{20, 10}[true]</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{20, 10}[1]     // true converts to 1</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #a9a1e1;">std</span>::cout &lt;&lt; x &lt;&lt; <span style="color: #a9a1e1;">std</span>::endl;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output: 10</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
</pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> If LLVM does it for you, whats the point?  如果 LLVM 能为你做，意义何在？</h4>
<aside class="notes">
<p>
LLVM only good at small cases.
For larger complex patterns like JSON.
The authors noticed several patterns in the data.
Exploited them and made all operations into SIMD.
Also by batching operations together like maybe do 1 type of operation over the entire string
We can basically almost use SIMD for the entire parsing instead of small minor optimizations.
</p>

</aside>
<ul>
<li>LLVM does it&rsquo;s best, but it cannot find everything     LLVM 已经做到最好，但并不能发现所有问题
<ul>
<li>good at small cases       擅长小案例</li>

</ul></li>
<li>some larger complex patterns     某些更大、更复杂的模式
<ul>
<li>human pattern recognition       人工模式识别</li>
<li>batching operations you can use simd       批量操作中可利用 SIMD</li>

</ul></li>

</ul>
</section>
<section id="slide-5-7">
<h3 id="5-7"><span class="section-number-3">5.7.</span> Write branchless code (bitwise operations)  编写无分支代码（位运算）</h3>
<div class="outline-text-3" id="text-5-7">
</div>
</section>
<section id="slide-5-7-1">
<h4 id="5-7-1"><span class="section-number-4">5.7.1.</span> Tricky memory layout  棘手的内存布局</h4>
<div class="org-src-container">

<pre class="src src-text">number = 305,419,896
number &lt;&lt; 1 # shift left logical
Number: 305,419,896
Hex: 0x12345678
Physical Memory Layout (lowest bit &#8594; highest bit)
   Addr Low                           Addr High
     0x1200                              0x1203
        |                                 |
        v                                 v
Before: 00011110 01101010 00110100 00010010
           &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;    &#8595;&#8595;&#8595;&#8595;&#8595;
After:  00001111 00110101 00010110 00100100
        &#8593;
        0 enters
Decimal: 610,839,792
Hexadecimal: 0x2468ACF0
</pre>
</div>
<aside class="notes">
<p>
need to know some low level operations to explain all the SIMD things later
</p>

</aside>
</section>
<section id="slide-5-7-2">
<h4 id="5-7-2"><span class="section-number-4">5.7.2.</span> Masking  掩码操作</h4>
<pre class="example">
a = 00001111
b = 11111100

and_op = a &amp; b
and_op = 00001100

 or_op = a | b
 or_op = 11111111

xor_or = a ^ b
xor_or = 11110011
</pre>
</section>
<section id="slide-5-7-3">
<h4 id="5-7-3"><span class="section-number-4">5.7.3.</span> Unset right most bit(blsr)  清除最右边的位 (blsr)</h4>
<pre class="example">
s = s &amp; (s-1)

a =     00101100
b =     (a - 1)
a =     00101100
b =     00101011
a &amp; b = 00101000
// rightmost bit is unset
</pre>
<ul>
<li>common cpu operation, compiler optimize to <code>blsr</code>     常见 CPU 操作，编译器会优化为 <code>blsr</code></li>

</ul>
</section>
<section id="slide-5-8">
<h3 id="5-8"><span class="section-number-3">5.8.</span> LLVM Compiler  LLVM 编译器</h3>
<aside class="notes">
<p>
One of the things to do to write fast code is know how the LLVM compiler optimizes your code
There are many many optimizations available for us to use, so I will not go through them,
I&rsquo;ll just talk abit about how optimizations even work in the first place.
</p>

</aside>

<div id="org1697097" class="figure">
<p><img src="https://llvm.org/img/LLVMWyvernSmall.png" alt="LLVMWyvernSmall.png" />
</p>
</div>
</section>
<section id="slide-5-8-1">
<h4 id="5-8-1"><span class="section-number-4">5.8.1.</span> LLVM  LLVM</h4>
<aside class="notes">
<p>
LLVM is split up into 3 parts,
Frontend, middle-end and backend
</p>

<p>
the front end will read our c++ source code and output something called a Intermediate Representation
</p>

<p>
Then the IR will be optimized then the backend will target different cpu platforms like X86, ARM and PowerPC
</p>

<p>
Thats all LLVM is, its not that difficult
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">      Frontend         Middle-end              Backend
             &#8595;                &#8595;              &#8601;         &#8600;
Source Code &#8594; LLVM IR &#8594; [Optimized IR] &#8594; [Assembly] &#8594; Machine Code
                                     &#8600;________________&#8599;
                                     (direct path option)
</pre>
</div>
</section>
<section id="slide-5-8-2">
<h4 id="5-8-2"><span class="section-number-4">5.8.2.</span> Without LLVM IR  没有 LLVM IR 的情况</h4>
<aside class="notes">
<p>
Why do we need to have this IR
Every new language we add we need to write compilers to target all the outputs
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">Without LLVM IR (n*m: 3 languages &#215; 3 targets = 9 compilers)
---------------------------------------------------------
C++   ----&#8594;  x86_64
      \---&#8594;  AMD
       \--&#8594;  ARM

Rust  ----&#8594;  x86_64
      \---&#8594;  AMD
       \--&#8594;  ARM

Haskell --&#8594;  x86_64
        \-&#8594;  AMD
         \&#8594;  ARM

Each arrow represents a separate compiler frontend+backend (9 total)
</pre>
</div>
</section>
<section id="slide-5-8-3">
<h4 id="5-8-3"><span class="section-number-4">5.8.3.</span> With LLVM IR  使用 LLVM IR</h4>
<aside class="notes">
<p>
We just write one compiler to target the IR then it can just generate the output for each architecture
Any optimizations and improvements to the compiler on the right side, we get it for free on the left side.
</p>

</aside>
<div class="org-src-container">

<pre class="src src-text">With LLVM IR (n+m: 3 frontends + 3 backends = 6 components)
--------------------------------------------------------

            &#9581;&#8594; x86_64
C++    &#9582;    &#9474;
       &#8595;    &#9474;
Rust   &#9473;&#9473;&#8594; IR &#9473;&#9473;&#8594; AMD
       &#8593;    &#9474;
Haskell&#9583;    &#9474;
            &#9584;&#8594; ARM

            &#9482;
            &#8595;
    Shared Optimizations
    - Dead code elimination
    - Loop vectorization
    - Constant propagation
    - And many more...
</pre>
</div>
</section>
<section id="slide-5-8-4">
<h4 id="5-8-4"><span class="section-number-4">5.8.4.</span> Intermediate Representation Example(IR)  中间表示 (IR) 示例</h4>
<aside class="notes">
<p>
Lets talk about an example code here very simple for loop
sum += i*4
return
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">example2</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">sum</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   sum += i * <span style="color: #da8548; font-weight: bold;">4</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Multiplication in loop</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> sum;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-5-8-5">
<h4 id="5-8-5"><span class="section-number-4">5.8.5.</span> Unoptimized IR -O0  未优化的 IR -O0</h4>
<aside class="notes">
<p>
If we compile with -O0, optimization level 0, no optimization
This is the IR
its this cpu agnostic code that has as much information retained from the original source code as possible
this is because to optimize, the compiler has to know what data types its dealing with
and then it can draw a computation graph to eliminate useless computation
</p>

</aside>
<div class="org-src-container">

<pre class="src src-llvm-ts">define dso_local i32 @_Z8example2i(i32 %<span style="color: #da8548; font-weight: bold;">0</span>) {
entry:
  %n = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  %sum = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  %i = alloca i32, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 %<span style="color: #da8548; font-weight: bold;">0</span>, ptr %n, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 <span style="color: #da8548; font-weight: bold;">0</span>, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  store i32 <span style="color: #da8548; font-weight: bold;">0</span>, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.cond

for.cond:
  %<span style="color: #da8548; font-weight: bold;">1</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %<span style="color: #da8548; font-weight: bold;">2</span> = load i32, ptr %n, align <span style="color: #da8548; font-weight: bold;">4</span>
  %cmp = icmp slt i32 %<span style="color: #da8548; font-weight: bold;">1</span>, %<span style="color: #da8548; font-weight: bold;">2</span>
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %<span style="color: #da8548; font-weight: bold;">3</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %mul = mul nsw i32 %<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>
  %<span style="color: #da8548; font-weight: bold;">4</span> = load i32, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  %add = add nsw i32 %<span style="color: #da8548; font-weight: bold;">4</span>, %mul
  store i32 %add, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.inc

for.inc:
  %<span style="color: #da8548; font-weight: bold;">5</span> = load i32, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  %inc = add nsw i32 %<span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">1</span>
  store i32 %inc, ptr %i, align <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.cond

for.end:
  %<span style="color: #da8548; font-weight: bold;">6</span> = load i32, ptr %sum, align <span style="color: #da8548; font-weight: bold;">4</span>
  ret i32 %<span style="color: #da8548; font-weight: bold;">6</span>
}
</pre>
</div>
</section>
<section id="slide-5-8-6">
<h4 id="5-8-6"><span class="section-number-4">5.8.6.</span> Unoptimized IR -O0 Graph  未优化 IR -O0 图</h4>

<div id="orgaaa9c4f" class="figure">
<p><img src="attachments/unoptimized-ir.png" alt="unoptimized-ir.png" />
</p>
</div>
</section>
<section id="slide-5-8-7">
<h4 id="5-8-7"><span class="section-number-4">5.8.7.</span> Optimized IR -O2  优化后的 IR -O2</h4>
<aside class="notes">
<p>
this is compiled with -O2
</p>

</aside>
<div class="org-src-container">

<pre class="src src-llvm-ts">define dso_local i32 @_Z8example2i(i32 %<span style="color: #da8548; font-weight: bold;">0</span>) local_unnamed_addr #<span style="color: #da8548; font-weight: bold;">0</span> {
entry:
  %cmp6 = icmp sgt i32 %<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>
  br i1 %cmp6, label %for.body.preheader, label %for.end

for.body.preheader:
  %<span style="color: #da8548; font-weight: bold;">1</span> = add i32 %<span style="color: #da8548; font-weight: bold;">0</span>, -<span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">2</span> = mul i32 %<span style="color: #da8548; font-weight: bold;">0</span>, %<span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">3</span> = lshr i32 %<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>
  %<span style="color: #da8548; font-weight: bold;">4</span> = mul i32 %<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>
  br label %for.end

for.end:
  %sum.0.lcssa = phi i32 [ <span style="color: #da8548; font-weight: bold;">0</span>, %entry ], [ %<span style="color: #da8548; font-weight: bold;">4</span>, %for.body.preheader ]
  ret i32 %sum.0.lcssa
}
</pre>
</div>
</section>
<section id="slide-5-8-8">
<h4 id="5-8-8"><span class="section-number-4">5.8.8.</span> Optimized IR -O2 Graph  优化后的 IR -O2 图</h4>
<aside class="notes">
<p>
with deadcode eliminated
</p>

</aside>

<div id="orgb96ef5e" class="figure">
<p><img src="attachments/optimized-ir.png" alt="optimized-ir.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Simdjson Implementation  Simdjson 实现</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> simdjson Architecture Overview  simdjson 架构概述</h3>
<ol>
<li>Stage 1: Structural Index Creation (find location of important markers)    阶段 1：结构索引创建（查找重要标记的位置）
<ol>
<li>Find structural characters ({,},[,],&ldquo;,,:)       查找结构字符（{, }, [, ], &rdquo;, :, ,）</li>
<li>Identify string boundaries       确定字符串边界</li>
<li>Locate whitespace       定位空白字符</li>
<li>Validate UTF-8 encoding       验证 UTF-8 编码</li>
<li>Detect pseudo-structural characters       检测伪结构字符</li>

</ol></li>
<li>Stage 2: Parsing &amp; Tape Building    阶段 2：解析与 Tape 构建
<ol>
<li>Parse atomic values (strings, numbers, true/false/null)       解析原子值（字符串、数字、true/false/null）</li>
<li>Validate document structure       验证文档结构</li>
<li>Build navigable tape representation       构建可导航的 Tape 表示</li>
<li>Convert numbers to machine formats       将数字转换为机器格式</li>
<li>Normalize strings to UTF-8       将字符串规范化为 UTF-8</li>

</ol></li>

</ol>
</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> simdjson diagram  simdjson 图示</h3>
<div class="org-src-container">

<pre class="src src-text">    JSON INPUT STRING
   "{"name": "value"}"
            &#11015;
     64-BYTE CHUNKS
   &#9556;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9559;
   &#9553;"{"name": "val...&#9553;
   &#9562;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9552;&#9565;
            &#11015;
         STAGE 1
  (Bitmap Generation &amp;   find: ([, {, ], }, :, ,)
   Index Extraction)     escaped characters and quoted regions
            &#11015;            Validate UTF-8
       INDEX ARRAY
      [0,3,5,7,...]
            &#11015;
         STAGE 2         parse number, int, float, 1e10, true, false, null, string
   (Parse &amp; Build Tape)  build tape to navigate
            &#11015;
       FINAL TAPE
[root, {, "name", "value", }]
</pre>
</div>
</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> Stage 1: Structural and Pseudo Structural Index Construction  阶段 1：结构和伪结构索引构建</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</section>
<section id="slide-6-3-1">
<h4 id="6-3-1"><span class="section-number-4">6.3.1.</span> Input and Output  输入与输出</h4>
<ul>
<li>Input: Raw JSON bytes       输入：原始 JSON 字节</li>
<li>Output:       输出：
<ul>
<li>Bitmask of structural chars         结构字符的位掩码</li>
<li>Array of integer indices marking structural elements         标记结构元素的整数索引数组</li>

</ul></li>

</ul>
</section>
<section id="slide-6-3-2">
<h4 id="6-3-2"><span class="section-number-4">6.3.2.</span> Key Responsibilities  主要职责</h4>
<ol>
<li>Character encoding validation (UTF-8)        字符编码验证（UTF-8）</li>
<li>Locate structural characters ([, {, ], }, :, ,)        定位结构字符（[, {, ], }, :, ,）</li>
<li>Identify string boundaries        确定字符串边界
<ol>
<li>Handles escaped characters and quoted regions       处理转义字符和引号区域</li>

</ol></li>
<li>Find pseudo-structural characters (atoms like numbers, true, false, null)        查找伪结构字符（如数字、true、false、null 等原子值）</li>

</ol>
</section>
<section id="slide-6-4">
<h3 id="6-4"><span class="section-number-3">6.4.</span> Stage 2: Structured Navigation  阶段 2：结构化导航</h3>
<div class="outline-text-3" id="text-6-4">
</div>
</section>
<section id="slide-6-4-1">
<h4 id="6-4-1"><span class="section-number-4">6.4.1.</span> Input and Output  输入与输出</h4>
<ul>
<li>Input: Array of structural indices from Stage 1       输入：阶段 1 中生成的结构索引数组</li>
<li>Output: Parsed JSON structure on a &ldquo;tape&rdquo;(array)       输出：以“Tape”（数组）形式表示的解析后 JSON 结构</li>
<li>Purpose: Build navigable representation of JSON document       目的：构建可导航的 JSON 文档表示</li>

</ul>
</section>
<section id="slide-6-4-2">
<h4 id="6-4-2"><span class="section-number-4">6.4.2.</span> Key Responsibilities  主要职责</h4>
<ol>
<li>Parse strings and convert to UTF-8        解析字符串并转换为 UTF-8</li>
<li>Convert numbers to 64-bit integers or doubles        将数字转换为 64 位整数或双精度浮点数</li>
<li>Validate structural rules (matching braces, proper sequences)        验证结构规则（括号匹配、正确的序列）</li>
<li>Build navigable tape structure        构建可导航的 Tape 结构</li>

</ol>
</section>
<section id="slide-6-4-3">
<h4 id="6-4-3"><span class="section-number-4">6.4.3.</span> The Tape Format  Tape 格式</h4>
<ul>
<li>64-bit words for each node        每个节点使用 64 位字</li>
<li>Special encoding for different types:        针对不同类型的特殊编码：
<ul>
<li>Atoms (null, true, false): n/t/f × 2^56        原子值（null, true, false）：n/t/f × 2^56</li>
<li>Numbers: Two 64-bit words        数字：两个 64 位字</li>
<li>Arrays/Objects: Start/end markers with navigation pointers        数组/对象：起始/结束标记及导航指针</li>
<li>Strings: Pointer to string buffer        字符串：指向字符串缓冲区的指针</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Stage 1: Structural and Pseudo Structural Index Construction  阶段 1：结构和伪结构索引构建</h2>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">whitespace_table</span> = <span style="color: #a9a1e1;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>::repeat_16<span style="color: #51afef;">(</span><span style="color: #98be65;">' '</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">17</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">113</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #98be65;">'\t'</span>, <span style="color: #98be65;">'\n'</span>, <span style="color: #da8548; font-weight: bold;">112</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #98be65;">'\r'</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">100</span><span style="color: #51afef;">)</span>;
 
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">op_table</span> = <span style="color: #a9a1e1;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>::repeat_16<span style="color: #51afef;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #98be65;">':'</span>, <span style="color: #98be65;">'{'</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">: = 3A, [ = 5B, { = 7B</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">','</span>, <span style="color: #98be65;">'}'</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">, = 2C, ] = 5D, } = 7D</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">)</span>;
 
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">whitespace</span> = in.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>whitespace_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Turn [ and ] into { and }</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8x64</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #dcaeea;">curlified</span><span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   in.chunks<span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">]</span> | <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">20</span>,
<span style="color: #3dea43364a63;"> </span>   in.chunks<span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">]</span> | <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">20</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">op</span> = curlified.eq<span style="color: #51afef;">(</span><span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>op_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>,
<span style="color: #3dea43364a63;"> </span>   _mm256_shuffle_epi8<span style="color: #98be65;">(</span>op_table, in.chunks<span style="color: #a9a1e1;">[</span><span style="color: #da8548; font-weight: bold;">1</span><span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span><span style="color: #51afef;">)</span>;
 
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">{</span> whitespace, op <span style="color: #51afef;">}</span>;
</pre>
</div>
</section>
<section id="slide-7-1">
<h3 id="7-1"><span class="section-number-3">7.1.</span> Stage 1: 1 Vectorized Classification and Pseudo-Structural Characters  阶段 1：1 向量化分类与伪结构字符</h3>
<ul>
<li>Want to obtain location of structural characters  ({, }, [, ], :, ,)        需要获取结构字符的位置（{, }, [, ], :, ,)
<ul>
<li>pseudo-structural - Any non‐whitespace character that immediately follows a structural character or whitespace        伪结构字符 —— 紧跟在结构字符或空白字符之后的任意非空白字符</li>
<li>useful for parsing, we need this bit mask to build tape        对解析非常有用，我们需要此位掩码来构建 Tape</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }
__1______________1___1________1____1_______1________1___1_______
</pre>
</div>
</section>
<section id="slide-7-1-1">
<h4 id="7-1-1"><span class="section-number-4">7.1.1.</span> Vectorized Classification  向量化分类</h4>
<aside class="notes">
<p>
We need to classify structural characters
each different class gets its own type
we need to do this classification fast we will use a look up table to do the classification, basically O(1)
</p>

</aside>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">code points</th>
<th scope="col" class="org-left">character</th>
<th scope="col" class="org-right">desired value</th>
<th scope="col" class="org-right">bin</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0x2c</td>
<td class="org-left">`,` (comma)</td>
<td class="org-right">1</td>
<td class="org-right">00001</td>
</tr>

<tr>
<td class="org-right">0x3a</td>
<td class="org-left">`:` (colon)</td>
<td class="org-right">2</td>
<td class="org-right">00010</td>
</tr>

<tr>
<td class="org-right">0x5b</td>
<td class="org-left">`[`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x5d</td>
<td class="org-left">`]`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x7b</td>
<td class="org-left">`{`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x7d</td>
<td class="org-left">`}`</td>
<td class="org-right">4</td>
<td class="org-right">00100</td>
</tr>

<tr>
<td class="org-right">0x09</td>
<td class="org-left">TAB</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x0a</td>
<td class="org-left">LF</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x0d</td>
<td class="org-left">CR</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>

<tr>
<td class="org-right">0x20</td>
<td class="org-left">SPACE</td>
<td class="org-right">16</td>
<td class="org-right">10000</td>
</tr>

<tr>
<td class="org-right">others</td>
<td class="org-left">any other</td>
<td class="org-right">0</td>
<td class="org-right">00000</td>
</tr>
</tbody>
</table>
<ul>
<li>PMOVMSKB     使用 PMOVMSKB
<ul>
<li>_mm256_movemask_epi8 to extract the bits into bitmap        使用 _mm256_movemask_epi8 将位提取成位图</li>

</ul></li>

</ul>
<ol class="org-ol">
<li><a id="7-1-1-1"></a>VPSHUFB: Vector Permute Shuffle Bytes  VPSHUFB：向量置换洗牌字节<br />
<aside class="notes">
<p>
If you have any experience with hashmaps, they are actually very slow
they are not truely o(1) lookup
the only true O(1) lookup structures are actually arrays, index + offset
hashing function is a fake O(1)
</p>

</aside>
<ul>
<li>basically a one instruction lookup table using the 4 lowest bit(nibble)        基本上利用最低 4 位（半字节）实现单指令查找表
<ul>
<li>0000 XXXX       0000 XXXX</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Lookup table for hex digits "0123456789abcdef"</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">lut</span> = _mm256_setr_epi8<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">'0'</span>, <span style="color: #98be65;">'1'</span>, <span style="color: #98be65;">'2'</span>, <span style="color: #98be65;">'3'</span>, <span style="color: #98be65;">'4'</span>, <span style="color: #98be65;">'5'</span>, <span style="color: #98be65;">'6'</span>, <span style="color: #98be65;">'7'</span>, <span style="color: #98be65;">'8'</span>, <span style="color: #98be65;">'9'</span>, <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span>, <span style="color: #98be65;">'d'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'f'</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">'0'</span>, <span style="color: #98be65;">'1'</span>, <span style="color: #98be65;">'2'</span>, <span style="color: #98be65;">'3'</span>, <span style="color: #98be65;">'4'</span>, <span style="color: #98be65;">'5'</span>, <span style="color: #98be65;">'6'</span>, <span style="color: #98be65;">'7'</span>, <span style="color: #98be65;">'8'</span>, <span style="color: #98be65;">'9'</span>, <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span>, <span style="color: #98be65;">'d'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'f'</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example 2: Alternating normal/zeroed values (0x00,0x80,0x01,0x81...)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">indices2</span> = _mm256_setr_epi8<span style="color: #c678dd;">(</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">00</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">80</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">01</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">81</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">02</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">82</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">03</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">83</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">04</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">84</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">05</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">85</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">06</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">86</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">07</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">87</span>,
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">08</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">88</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">09</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">89</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0A</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8A</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0B</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8B</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0C</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8C</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0D</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8D</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0E</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8E</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">0F</span>, <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">8F</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">)</span>;
 
<span style="color: #3dea43364a63;"> </span>   printf<span style="color: #c678dd;">(</span><span style="color: #98be65;">"\nAlternating with zeroes (. represents zero):\n"</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   print_bytes<span style="color: #c678dd;">(</span>_mm256_shuffle_epi8<span style="color: #98be65;">(</span>lut, indices2<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Alternating with zeroes (. represents zero):</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef; font-weight: bold;">#pragma</span> <span style="color: #a9a1e1;">GCC</span> target<span style="color: #51afef;">(</span><span style="color: #98be65;">"avx2"</span><span style="color: #51afef;">)</span>
<span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">immintrin.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">stdio.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">print_bytes</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">v</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">bytes</span><span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">32</span><span style="color: #c678dd;">]</span>;
<span style="color: #3dea43364a63;"> </span>   _mm256_storeu_si256<span style="color: #c678dd;">(</span><span style="color: #98be65;">(</span><span style="color: #ECBE7B;">__m256i</span>*<span style="color: #98be65;">)</span>bytes, v<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">32</span>; i++<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span>bytes<span style="color: #a9a1e1;">[</span>i<span style="color: #a9a1e1;">]</span><span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   printf<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"%c"</span>, bytes<span style="color: #51afef;">[</span>i<span style="color: #51afef;">]</span><span style="color: #a9a1e1;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   printf<span style="color: #a9a1e1;">(</span><span style="color: #98be65;">"."</span><span style="color: #a9a1e1;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Print dot for zero bytes</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #98be65;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   printf<span style="color: #c678dd;">(</span><span style="color: #98be65;">"\n"</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</li>
<li><a id="7-1-1-2"></a>Simple example  简单示例<br />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">code points</td>
<td class="org-left">character</td>
<td class="org-right">desired value</td>
<td class="org-right">bin</td>
</tr>

<tr>
<td class="org-right">0x3a</td>
<td class="org-left">`:` (colon)</td>
<td class="org-right">2</td>
<td class="org-right">00010</td>
</tr>

<tr>
<td class="org-right">0x0a</td>
<td class="org-left">LF</td>
<td class="org-right">8</td>
<td class="org-right">01000</td>
</tr>
</tbody>
</table>
<ul>
<li>use vpshufb to match low nibble a        使用 vpshufb 匹配低半字节 a</li>
<li>could be both : and LF so it must match 0010 | 1000 = 1010        可能既是 : 又是 LF，所以必须匹配 0010 | 1000 = 1010</li>
<li>low nibble at position A = 10        低半字节在位置 A = 10
<ul>
<li>high nibble 0x3 vs 0x0        高半字节 0x3 与 0x0
<ul>
<li>0x3 = 2         0x3 = 2</li>
<li>0x0 = 8         0x0 = 8</li>

</ul></li>

</ul></li>

</ul>
</li>
<li><a id="7-1-1-3"></a>Simple example  简单示例<br />
<pre class="example" id="org6db07a6">
"LF:"

Low nibble table
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
xx xx xx xx xx xx xx xx xx xx 10 xx xx xx xx xx
1010

high nibble table
00 .. 02 03 04 05 06 07 08 09 10 11 12 13 14 15
08 .. 02 xx xx xx xx xx xx xx xx xx xx xx xx xx
0100,  0010
</pre>
<ol class="org-ol">
<li><a id="7-1-1-3-1"></a>Simple example  简单示例<br />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">LF</td>
<td class="org-right">:</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">low</td>
<td class="org-right">1010</td>
<td class="org-right">1010</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">high</td>
<td class="org-right">1000</td>
<td class="org-right">0010</td>
</tr>

<tr>
<td class="org-left">AND</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1000</td>
<td class="org-right">0010</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">8</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
</ol>
</section>
<section id="slide-7-1-2">
<h4 id="7-1-2"><span class="section-number-4">7.1.2.</span> Stage 1: Bitmap to Array index  阶段 1：位图转换为数组索引</h4>
<div class="outline-text-4" id="text-7-1-2">
</div>
<ol class="org-ol">
<li><a id="7-1-2-1"></a>input data  输入数据<br />
<aside class="notes">
<p>
In stage 1, we our functions take in 64 byte * 8 bit blocks
and output bitmasks of 64 bits each
we have several bit mask types
</p>

<p>
quotes, between quotes, structure, whitespace
</p>

<p>
however these masks are sparse, sometimes it can be 4 char before we a faced with a 1
sometimes the spaces are 4, and the spaces could be 40.
</p>

<p>
if we iterate through this and process it with if else statements, its unpredictable branching and will cause performance penalty, mson does this
</p>

<p>
as such we want to extract the bits into a list of indexes instead of working directly with the bitsets.
</p>

</aside>
<blockquote>
<p>
{ &ldquo;\\\&rdquo;Nam[{&ldquo;: [ 116,&rdquo;\\\\&ldquo; , 234, &rdquo;true&ldquo;, false ], &rdquo;t&ldquo;:&rdquo;\\\&ldquo;&rdquo; }: input data
<span class="underline"><span class="underline">1_________1________1____1________1____1___________1_1_1____1</span></span>: Q
1_________11_1_1____1_______1____1_______1_______11____1_______1: S
<span class="underline">1____________1_1__________1_1____1_______1_____1__1__________1</span>: W
</p>
</blockquote>
<ul>
<li>take Q for example, we want to convert Q&rsquo;s bit mask into a list of indexes        以 Q 为例，我们希望将 Q 的位掩码转换为索引列表
<ul>
<li>[2, 12, 22, 27, 37, 42, 54, 56, 58, 62]        [2, 12, 22, 27, 37, 42, 54, 56, 58, 62]</li>

</ul></li>

</ul>
</li>
<li><a id="7-1-2-2"></a>extraction<br />
<ul>
<li>2 instructions     2 条指令</li>
<li>tzcnt count trailing least significant 0 bits        tzcnt 用于计算尾部最低有效的 0 位数</li>
<li>blsr which delete the last bit.        blsr 用于清除最低位</li>

</ul>
<div class="org-src-container">

<pre class="src src-text">a = 1010000
idx = tzcnt(a) // 4
a = blsr(a)    // 1000000
idx = tzcnt(a) // 6
</pre>
</div>
</li>
<li><a id="7-1-2-3"></a>Naive Implementation  天真的实现<br />
<aside class="notes">
<p>
the compiler will automatically optimize this into the tzcnt and blsr
that while loop is the part with the unpredictable branching which will cost 10-20 cycles for every wrong prediction
how do we solve it?
</p>

</aside>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_unoptimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">pos</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This while loop is the source of unpredictable branches</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Find position of lowest set bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">bit_pos</span> = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Store the position</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = bit_pos;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear the lowest set bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</li>
<li><a id="7-1-2-4"></a>Minimal branching implementation  最小化分支实现<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_optimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get total number of set bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">count</span> = __builtin_popcountll<span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">next_base</span> = output + count;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Process 8 bits at a time unconditionally</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Extract next 8 set bit positions, even if we don't have 8 bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear lowest set bit (blsr instruction)</span>
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Reset output pointer to actual end based on real count</span>
<span style="color: #3dea43364a63;"> </span>   output = next_base;
<span style="color: #51afef;">}</span>
</pre>
</div>
</li>
</ol>
</section>
<section id="slide-7-2">
<h3 id="7-2"><span class="section-number-3">7.2.</span> Stage 1: 2 Eliminated escaped or quoted substring  阶段 1：2 消除转义或引号内子字符串</h3>
<div class="outline-text-3" id="text-7-2">
</div>
</section>
<section id="slide-7-2-1">
<h4 id="7-2-1"><span class="section-number-4">7.2.1.</span> Get backslash  获取反斜杠</h4>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
___111________________1111_______________________________111____: B = backslash_bits
____111_________________1111______________________________111___: bits_shifted_left = backslash_bits &lt;&lt; 1

___111________________1111_______________________________111____: bits
____000_________________0000______________________________000___: inverted = ~bits_shifted_left
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
// we get the first backslash of every group
</pre>
</div>
</section>
<section id="slide-7-2-2">
<h4 id="7-2-2"><span class="section-number-4">7.2.2.</span> Get odd length sequences starting on an odd offset  获取在奇数偏移开始的奇数长度序列</h4>
<div class="org-src-container">

<pre class="src src-text">_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
___111________________1111_______________________________111____: B = backslash_bits
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
___1_____________________________________________________1______: OS = S &amp; O

// add B to OS, yielding carries on backslash sequences with odd starts
___1_____________________________________________________1______: OS = S &amp; O
___111________________1111_______________________________111____: B = backslash_bits
   --&gt;                                                   --&gt;
______1_______________1111__________________________________1___: OC = B + OS

// filter out the backslashes from the previous addition, getting carries only
___111________________1111_______________________________111____: B = backslash_bits
___000________________0000_______________________________000____: ~B
______1_______________1111__________________________________1___: OC = B + OS
______1_____________________________________________________1___: OCO = OC &amp; ~B

// get the odd-length sequence starting on an odd offset and ending on even offset
______1_____________________________________________________1___: OCO = OC &amp; ~B
1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: E (constant)
______1_____________________________________________________1___: OD2 = OCO &amp; E
// this shows two odd-length sequence starting on an odd offset
</pre>
</div>
</section>
<section id="slide-7-2-3">
<h4 id="7-2-3"><span class="section-number-4">7.2.3.</span> Get odd length sequences starting on an even offset  获取在偶数偏移开始的奇数长度序列</h4>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
___1__________________1__________________________________1______: S = starts = bits &amp; inverted
______________________1_________________________________________: ES = S &amp; E
___111________________1111_______________________________111____: B = backslash_bits
// add B to ES, yielding carries on backslash sequences with even starts
                      ---&gt;
___111____________________1______________________________111____: EC = B + ES
// filter out the backslashes from the previous addition, getting carries only
__________________________1_____________________________________: ECE = EC &amp; ~B
// select only the end of sequences ending on an odd offset
__________________________1_____________________________________: ECE = EC &amp; ~B
_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1: O (constant)
________________________________________________________________: OD1 = ECE &amp; ~E
// there are no odd-length sequences of backslashes starting on an even offset
</pre>
</div>
</section>
<section id="slide-7-2-4">
<h4 id="7-2-4"><span class="section-number-4">7.2.4.</span> Get sequences with odd offset  获取奇数偏移的序列</h4>
<div class="org-src-container">

<pre class="src src-text">// merge results, yielding ends of all odd-length sequence of backslashes
________________________________________________________________: OD1 = ECE &amp; ~E
______1_____________________________________________________1___: OD2 = OCO &amp; E

______1_____________________________________________________1___: OD = OD1 | OD2
{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data

// these " are escaped and thus are counted as text instead of structural characters
</pre>
</div>
</section>
<section id="slide-7-2-5">
<h4 id="7-2-5"><span class="section-number-4">7.2.5.</span> Eliminated escape  消除转义</h4>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
__1___1_____1________1____1________1____1___________1_1_1___11__: Q = quotes
______1_____________________________________________________1___: OD
// we remove the escaped " quotes
__1_________1________1____1________1____1___________1_1_1____1__: Q &amp;= ~OD
__1111111111_________11111_________11111____________11__11111___: CLMUL(Q,~0)
</pre>
</div>
</section>
<section id="slide-7-2-6">
<h4 id="7-2-6"><span class="section-number-4">7.2.6.</span> Sweeping  扫描 (Sweeping)</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #c678dd;">xorShiftOperations</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">num</span>, <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">rightShift</span>, <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">tutorial</span> = <span style="color: #a9a1e1;">false</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Array of shift amounts</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">shifts</span><span style="color: #c678dd;">[]</span> = <span style="color: #c678dd;">{</span><span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">16</span>, <span style="color: #da8548; font-weight: bold;">32</span><span style="color: #c678dd;">}</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">result</span> = num;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">for</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">shift</span> : shifts<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   result ^= <span style="color: #98be65;">(</span>result &lt;&lt; shift<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0000000000000000000010000000000000000000000000000000000000000000</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">after apply</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0000000000000000000011111111111111111111111111111111111111111111</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0001000000000000000000000000000000000000000000000000000000000000</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">after apply</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0001111111111111111111111111111111111111111111111111111111111111</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> result;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-7-2-7">
<h4 id="7-2-7"><span class="section-number-4">7.2.7.</span> Sweeping  扫描 (Sweeping)</h4>
<div class="org-src-container">

<pre class="src src-text">// 0000000000000000000010000000000000000000000000000000000000000000
// OR
// 0001000000000000000000000000000000000000000000000000000000000000
// result
// 0001000000000000000010000000000000000000000000000000000000000000

// 0000000000000000000011111111111111111111111111111111111111111111
// XOR
// 0001111111111111111111111111111111111111111111111111111111111111
// result
// 0001111111111111111100000000000000000000000000000000000000000000

</pre>
</div>
</section>
<section id="slide-7-2-8">
<h4 id="7-2-8"><span class="section-number-4">7.2.8.</span> Sweeping  扫描 (Sweeping)</h4>
<div class="org-src-container">

<pre class="src src-text">Testing left shift:
Initial number:
0x00      00100000 00001000 00000100 00100000 00010000 10000000 00001010 10000100       0x07
After left shift by 1:
0x00      00110000 00001100 00000110 00110000 00011000 11000000 00001111 11000110       0x07
After left shift by 2:
0x00      00111100 00001111 00000111 10111100 00011110 11110000 00001100 00110111       0x07
After left shift by 4:
0x00      00111111 11001111 11110111 11000111 11011111 00011111 00001100 11110100       0x07
After left shift by 8:
0x00      00111111 11110000 00111000 00110000 00011000 11000000 00010011 11111000       0x07
After left shift by 16:
0x00      00111111 11110000 00000111 11000000 00100000 11110000 00001011 00111000       0x07
After left shift by 32:
0x00      00111111 11110000 00000111 11000000 00011111 00000000 00001100 11111000       0x07
</pre>
</div>
</section>
<section id="slide-7-2-9">
<h4 id="7-2-9"><span class="section-number-4">7.2.9.</span> Sweeping implemented by CLMUL, pclmulqdq  使用 CLMUL（无进位乘法）实现的扫描</h4>
<div class="org-src-container">

<pre class="src src-text">        4
X      20
----------
        4
X (16 + 4)
----------
       16
+      64
----------
       80
----------
</pre>
</div>
</section>
<section id="slide-7-2-10">
<h4 id="7-2-10"><span class="section-number-4">7.2.10.</span> Sweeping implemented by CLMUL, pclmulqdq  使用 CLMUL（无进位乘法）实现的扫描</h4>
<div class="org-src-container">

<pre class="src src-text">- CLMUL(4, 20)
- XOR ~= ADD
</pre>
</div>
</section>
<section id="slide-7-2-11">
<h4 id="7-2-11"><span class="section-number-4">7.2.11.</span> Sweeping implemented by CLMUL, pclmulqdq  使用 CLMUL（无进位乘法）实现的扫描</h4>
<div class="org-src-container">

<pre class="src src-text">- CLMUL(inputJsonBitmask, EvenBitMask)
</pre>
</div>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">shifts</span><span style="color: #51afef;">[]</span> = <span style="color: #51afef;">{</span><span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">16</span>, <span style="color: #da8548; font-weight: bold;">32</span><span style="color: #51afef;">}</span>;
<span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">result</span> = num;
<span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">shift</span> : shifts<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   result ^= <span style="color: #c678dd;">(</span>result &lt;&lt; shift<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">01010101 01010101 01010101 01010101</span>

<span style="color: #5B6268;">//            </span><span style="color: #5B6268;">input</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt;  1)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt;  2)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt;  4)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt;  8)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt; 16)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">XOR (input &lt;&lt; 32)</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">----------------</span>
<span style="color: #5B6268;">//       </span><span style="color: #5B6268;">quote mask</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">----------------</span>
</pre>
</div>
</section>
<section id="slide-7-2-12">
<h4 id="7-2-12"><span class="section-number-4">7.2.12.</span> finally get quote mask  最终得到引号掩码</h4>
<div class="org-src-container">

<pre class="src src-text">{ "\\\"Nam[{": [ 116,"\\\\" , 234, "true", false ], "t":"\\\"" }: input data
__1111111111_________11111_________11111____________11__11111___: CLMUL(Q,~0)
</pre>
</div>
</section>
<section id="slide-7-3">
<h3 id="7-3"><span class="section-number-3">7.3.</span> Stage 1: 3 Character-Encoding Validation  阶段 1：3 字符编码验证</h3>
<ol>
<li>Initial ASCII Fast Path, first bit == 0        初始 ASCII 快速通路，首位为 0</li>
<li>Main algorithm        主算法
<ol>
<li>Range check(0xF4 saturated subtract)        范围检查（0xF4 饱和减法）</li>
<li>Continuation Byte validation        连续字节验证</li>

</ol></li>

</ol>
</section>
<section id="slide-7-3-1">
<h4 id="7-3-1"><span class="section-number-4">7.3.1.</span> Check for Ascii fast path  检查 ASCII 快速通路</h4>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data
</pre>
</div>
</section>
<section id="slide-7-3-2">
<h4 id="7-3-2"><span class="section-number-4">7.3.2.</span> Continuation Byte validation  连续字节验证</h4>
<div class="org-src-container">

<pre class="src src-text">Single byte (ASCII):
0xxxxxxx                     (values 0-127)
Values start with 0, remaining 7 bits for data

Two bytes:
110xxxxx 10xxxxxx           (values 128-2047)
First byte starts with 110

Three bytes:
1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
First byte starts with 1110

Four bytes:
1111xxxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
First byte starts with 11110
</pre>
</div>
<ol class="org-ol">
<li><a id="7-3-2-1"></a>map to values  映射到数值<br />
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">high</th>
<th scope="col" class="org-right">Dec</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">high</th>
<th scope="col" class="org-right">Dec</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1001</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1010</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1011</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1100</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1101</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1110</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1111</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>
<div class="org-src-container">

<pre class="src src-text">1111xxxx 10xxxxxx 10xxxxxx 10xxxxxx   (values 65536+)
4 0 0 0

1110xxxx 10xxxxxx 10xxxxxx  (values 2048-65535)
3 0 0
</pre>
</div>
</li>
<li><a id="7-3-2-2"></a>SIMD validation algorithm  SIMD 验证算法<br />
<div class="org-src-container">

<pre class="src src-text">4 0 0 0 3 0 0 2 0 1 1 1
  4 0 0 0 3 0 0 2 0 1 1 1 // &lt;&lt;= 1 byte, shift left by 1 byte
  3 0 0 0 2 0 0 1 0 0 0 0 // saturated subtract 1 from each byte

4 0 0 0 3 0 0 2 0 1 1 1
  3 0 0 0 2 0 0 1 0 0 0 0
4 3 0 0 3 2 0 2 1 1 1 1   // add it back into the original mapping

4 3 0 0 3 2 0 2 1 1 1 1   // add it back into the original mapping
    4 3 0 0 3 2 0 2 1 1 1 1   // &lt;&lt;= 2 byte, shift left by 2 bytes
    2 1 0 0 1 0 0 0 0 0 0 0   // saturated subtract 2
4 3 2 1 3 2 1 3 1 1 1 1   // add it back
// the end result will have no 0
// none of the numbers are bigger than the original
</pre>
</div>
</li>
<li><a id="7-3-2-3"></a>SIMD validation algorithm: Invalid example  SIMD 验证算法：无效示例<br />
<div class="org-src-container">

<pre class="src src-text">2 0 0 0 4 3 0 0
  2 0 0 0 4 3 0 // shift left 1
  1 0 0 0 3 2 0 // saturated subtract 1
2 1 0 0 4 6 2 0

2 1 0 0 4 6 2 0
    0 0 2 1 0 0 4 6 // shift left 2
    0 0 0 0 0 0 2 4 // saturated subtract 2
2 1 0 0 4 6 4 4

2 0 0 0 4 3 0 0
2 1 0 0 4 6 4 4
    --- zeros found here invalid
          - 6 &gt; 3
</pre>
</div>
</li>
</ol>
</section>
<section id="slide-7-3-3">
<h4 id="7-3-3"><span class="section-number-4">7.3.3.</span> Step-by-Step Visual Explanation  逐步视觉解释</h4>
<div class="outline-text-4" id="text-7-3-3">
</div>
<ol class="org-ol">
<li><a id="7-3-3-0-0-1"></a>Step 1: Initial masking of high nibbles  步骤 1：初始高半字节掩码<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint64</span> <span style="color: #dcaeea;">high_nibble</span> = val &amp; <span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">F0F0F0F0F0F0F0F0</span>;
</pre>
</div>
<ul>
<li>if you are lesser than 0x3X, you are 0x2F,        如果小于 0x3X，则为 0x2F，</li>
<li>Let&rsquo;s take valid input &ldquo;12345678&rdquo;:        以有效输入 &ldquo;12345678&rdquo; 为例:</li>

</ul>
<pre class="example" id="orgd4bc211">
Input bytes:    31 32 33 34 35 36 37 38
                || || || || || || || ||
                v| v| v| v| v| v| v| v|
High nibble:    3  3  3  3  3  3  3  3
                |  |  |  |  |  |  |  |
Mask:           F0 F0 F0 F0 F0 F0 F0 F0
                =  =  =  =  =  =  =  =
Result1:        30 30 30 30 30 30 30 30
</pre>
</li>
<li><a id="7-3-3-0-0-2"></a>How the low nibble check works  低半字节检查如何工作<br />
<ul>
<li>we want to ensure that low nibble is within 0xX0 - 0xX9        我们希望确保低半字节在 0xX0 到 0xX9 之间
<ul>
<li>0xXA - 0xXF is illegal        0xXA 到 0xXF 是非法的
<ul>
<li>Analyzing Carry Detection with Binary        使用二进制分析进位检测</li>

</ul></li>

</ul></li>

</ul>
</li>
<li><a id="7-3-3-0-0-3"></a>Case 1: Valid Digit (0x39 = &rsquo;9&rsquo;)  案例 1：有效数字 (0x39 = &rsquo;9&rsquo;)<br />
<pre class="example" id="org00980f0">
0x39 = 0011 1001  (Original value '9')
0x06 = 0000 0110  (Value we add)
      -----------
      0011 1111  (Result = 0x3F)
Low nibble does not overflow into high nibble and affect the 0x3 in high nibble

After masking high nibble (&amp; 0xF0):
0x3F = 0011 1111
0xF0 = 1111 0000
      -----------
      0011 0000  (= 0x30)

After right shift by 4:
0x30 &gt;&gt; 4 = 0000 0011  (= 0x03) ✓ Valid!
</pre>
</li>
<li><a id="7-3-3-0-0-4"></a>Case 2: Invalid Character (0x3A = &rsquo;:&rsquo;)  案例 2：无效字符 (0x3A = &rsquo;:&rsquo;)<br />
<pre class="example" id="org78d1b02">
0x3A = 0011 1010  (Original value ':')
0x06 = 0000 0110  (Value we add)
      -----------
       0011 0000
          1 0000
      -----------
      0100 0000  (Result = 0x40) &lt;- Notice the carry!
                                   The '1' carried into the high nibble

After masking high nibble (&amp; 0xF0):
0x40 = 0100 0000
0xF0 = 1111 0000
      -----------
      0100 0000  (= 0x40)

After right shift by 4:
0x40 &gt;&gt; 4 = 0000 0100  (= 0x04) ✗ Invalid!

 0x3X
|0xX4
-----
 0x34 &lt;- INVALID
-----
</pre>
</li>
<li><a id="7-3-3-0-0-5"></a>Step 2: Add 0x06 to detect non-digits  步骤 2：加上 0x06 以检测非数字<br />
<pre class="example" id="org3e17d2c">
Low nibbles:    1  2  3  4  5  6  7  8
Add 0x06:       7  8  9  A  B  C  D  E
                ^  ^  ^  ^  ^  ^  ^  ^
                |  |  |  |  |  |  |  |
If original &lt;= 9: No carry to high nibble
If original &gt; 9: Carry affects high nibble
</pre>
</li>
<li><a id="7-3-3-0-0-6"></a>Step 3: Example with valid digits (0-9)  步骤 3：有效数字 (0-9) 示例<br />
<pre class="example" id="org8b22fa3">

Original:       31 32 33 34 35 36 37 38
                v  v  v  v  v  v  v  v
high nibble:    30 30 30 30 30 30 30 30

Original:       31 32 33 34 35 36 37 38
After +0x06:    37 38 39 3A 3B 3C 3D 3E
Mask high:      30 30 30 30 30 30 30 30
low nibble:     03 03 03 03 03 03 03 03

high nibble:    30 30 30 30 30 30 30 30
low nibble:     03 03 03 03 03 03 03 03
OR together:    33 33 33 33 33 33 33 33
</pre>
</li>
<li><a id="7-3-3-0-0-7"></a>Step 4: Example with invalid character (&rsquo;;&rsquo; = 0x3B)  步骤 4：包含无效字符 (&rsquo;;&rsquo; = 0x3B) 的示例<br />
<pre class="example" id="org4060c97">
Original:       31 32 33 34 3B 36 37 38
After +0x06:    37 38 39 3A 41 3C 3D 3E
                               ^
                               |
Mask high:      30 30 30 30 40 30 30 30
                               ^ Different!
Shift right 4:  03 03 03 03 04 03 03 03
high nibble:    30 30 30 30 30 30 30 30
OR together:    33 33 33 33 34 33 33 33 ≠ 0x3333...
                               ^ Caught!
</pre>
</li>
</ol>
<li><a id="7-3-3-0-1"></a>Why It Works  原理解析<br />
<ol>
<li>First part (val &amp; 0xF0F0&#x2026;):        第一部分 (val &amp; 0xF0F0&#x2026;)：
<ul>
<li>Isolates high nibbles         隔离出高半字节</li>
<li>Must be 0x30 for valid digits         对于有效数字，高半字节必须为 0x30</li>

</ul></li>
<li>Second part ((val + 0x06&#x2026;) &amp; 0xF0&#x2026;):         第二部分 ((val + 0x06&#x2026;) &amp; 0xF0&#x2026;)：
<ul>
<li>Adding 0x06 to low nibble:         对低半字节加 0x06：
<ul>
<li>For 0-9: Result stays within nibble         对于 0-9：结果保持在半字节内</li>
<li>For &gt;9: Causes carry         对于大于 9 的数字：会产生进位</li>

</ul></li>
<li>After shift right 4:         右移 4 位后：
<ul>
<li>Valid digits: Always 0x03         有效数字始终为 0x03</li>
<li>Invalid: Different value         无效数字会产生不同的值</li>

</ul></li>

</ul></li>
<li>When OR&rsquo;d together:         按位或之后：
<ul>
<li>Valid digits: Always 0x33         有效数字总是 0x33</li>
<li>Invalid: Different pattern         无效数字会得到不同的模式</li>

</ul></li>

</ol>
</li>
<li><a id="7-3-3-0-2"></a>Examples with Different Cases  不同情况的示例<br />
<ol class="org-ol">
<li><a id="7-3-3-0-2-1"></a>Valid Cases  有效情况<br />
<pre class="example" id="org6d6c293">
"00000000" -&gt; 0x3333333333333333 ✓
"99999999" -&gt; 0x3333333333333333 ✓
"12345678" -&gt; 0x3333333333333333 ✓
</pre>
</li>
<li><a id="7-3-3-0-2-2"></a>Invalid Cases  无效情况<br />
<pre class="example" id="org69c146a">
"A" (0x41):
Original:  41
+0x06:     47
High:      40 ≠ 30 -&gt; Fails

"/" (0x2F):
Original:  2F
+0x06:     35
High:      20 ≠ 30 -&gt; Fails

":" (0x3A):
Original:  3A
+0x06:     40
High:      40 ≠ 30 -&gt; Fails
</pre>
</li>
</ol>
</li>
<li><a id="7-3-3-0-3"></a>Performance Benefits  性能优势<br />
<ul>
<li>Single comparison instead of 8 individual checks         仅一次比较替代 8 次单独检查</li>
<li>No branches (important for modern CPUs)         无分支（对现代 CPU 非常重要）</li>
<li>Uses native 64-bit operations         使用原生 64 位运算</li>
<li>Exploits CPU&rsquo;s ability to do parallel checks         利用 CPU 进行并行检查的能力</li>

</ul>

<p>
This algorithm is a beautiful example of bit manipulation that turns what would normally be 8 comparisons into a single mathematical test.  该算法是位操作的优美示例，将通常需要 8 次比较的过程转换为一次数学测试。
</p>
</li>
</ol>
</section>
<section id="slide-7-3-4">
<h4 id="7-3-4"><span class="section-number-4">7.3.4.</span> Understanding SIMD-Based Fast Eight-Digit Number Parsing  理解基于 SIMD 的快速八位数字解析</h4>
<div class="outline-text-4" id="text-7-3-4">
</div>
<ol class="org-ol">
<li><a id="7-3-4-1"></a>Overview<br />
<p>
Convert ASCII string of 8 digits to integer using SIMD instructions. 概述：使用 SIMD 指令将 8 位数字的 ASCII 字符串转换为整数.
Example: &ldquo;12345678&rdquo; -&gt; 12345678  例如：&ldquo;12345678&rdquo; -&gt; 12345678
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">uint32_t</span> <span style="color: #c678dd;">parse_eight_digits_unrolled</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">chars</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">ascii0</span> = _mm_set1_epi8<span style="color: #c678dd;">(</span>&#8217;<span style="color: #da8548; font-weight: bold;">0</span>&#8217;<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10</span> = _mm_setr_epi8<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_100</span> = _mm_setr_epi16<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">number_ascii</span> = _mm_loadu_si128<span style="color: #c678dd;">(</span><span style="color: #98be65;">(</span><span style="color: #ECBE7B;">__m128i</span> *<span style="color: #98be65;">)</span>chars<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">in</span> = _mm_sub_epi8<span style="color: #c678dd;">(</span>number_ascii, ascii0<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t1</span> = _mm_maddubs_epi16<span style="color: #c678dd;">(</span>in, mul_1_10<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t2</span> = _mm_madd_epi16<span style="color: #c678dd;">(</span>t1, mul_1_100<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t3</span> = _mm_packus_epi32<span style="color: #c678dd;">(</span>t2, t2<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t4</span> = _mm_madd_epi16<span style="color: #c678dd;">(</span>t3, mul_1_10000<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> _mm_cvtsi128_si32<span style="color: #c678dd;">(</span>t4<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</li>
<li><a id="7-3-4-2"></a>Step-by-Step Process  逐步过程<br />
<ol class="org-ol">
<li><a id="7-3-4-2-1"></a>Step 1: Convert ASCII to Numeric Values  步骤 1：将 ASCII 转换为数值<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">ascii0</span> = _mm_set1_epi8<span style="color: #51afef;">(</span>&#8217;<span style="color: #da8548; font-weight: bold;">0</span>&#8217;<span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">number_ascii</span> = _mm_loadu_si128<span style="color: #51afef;">(</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">__m128i</span> *<span style="color: #c678dd;">)</span>chars<span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">in</span> = _mm_sub_epi8<span style="color: #51afef;">(</span>number_ascii, ascii0<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="orgaee7b32">
Input:          "12345678"
ASCII values:   31 32 33 34 35 36 37 38
Subtract:       30 30 30 30 30 30 30 30
Subtract '0':   01 02 03 04 05 06 07 08  (numeric values)
                |  |  |  |  |  |  |  |
Instruction:    _mm_sub_epi8 (PSUBB - packed subtract bytes)
</pre>
</li>
<li><a id="7-3-4-2-2"></a>Step 2: Multiply Alternate Digits by 10 and Add  步骤 2：交替数字乘以 10 并相加<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10</span> = _mm_setr_epi8<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t1</span> = _mm_maddubs_epi16<span style="color: #51afef;">(</span>in, mul_1_10<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org76c507a">
Values:         1  2  3  4  5  6  7  8
Multipliers:   10  1 10  1 10  1 10  1
                |  |  |  |  |  |  |  |
Results:       10  2 30  4 50  6 70  8
                \ /   \ /   \ /   \ /
Sums:           12    34    56    78     (as 16-bit values)

Instruction: _mm_maddubs_epi16 (PMADDUBSW - multiply and add unsigned bytes to signed words)
</pre>
</li>
<li><a id="7-3-4-2-3"></a>Step 3: Multiply Alternate 16-bit Values by 100  步骤 3：交替 16 位数值乘以 100<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_100</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">100</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t2</span> = _mm_madd_epi16<span style="color: #51afef;">(</span>t1, mul_1_100<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="orgc9c6d6e">
Values:        12   34   56   78
Multipliers:  100    1  100    1
                |    |    |    |
Results:     1200   34 5600   78
                 \ /       \ /
Sums:           1234      5678    (as 32-bit values)

Instruction: _mm_madd_epi16 (PMADDWD - multiply and add packed words)
</pre>
<ul>
<li>what is the next step? 10000?        下一步是什么？10000?</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
</pre>
</div>
</li>
<li><a id="7-3-4-2-4"></a>Step 4: Pack 32-bit Values to 16-bit  步骤 4：将 32 位数值打包成 16 位<br />
<ul>
<li>so we can use _mm_setr_epi16 instead of _mm_setr_epi32        因此我们可以使用 _mm_setr_epi16 而非 _mm_setr_epi32
<ul>
<li>its more efficient         这样更高效</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint16</span> <span style="color: #dcaeea;">max_value</span> = <span style="color: #da8548; font-weight: bold;">65536</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t3</span> = _mm_packus_epi32<span style="color: #51afef;">(</span>t2, t2<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="org70d7b4b">
Before:   1234(32-bit)  5678(32-bit)
After:    1234(16-bit)  5678(16-bit)

Instruction: _mm_packus_epi32 (PACKUSDW - pack with unsigned saturation)
</pre>
</li>
<li><a id="7-3-4-2-5"></a>Step 5: Final Combine with Multiply by 10000  步骤 5：最终结合，乘以 10000<br />
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">mul_1_10000</span> = _mm_setr_epi16<span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">10000</span>, <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #51afef;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #ECBE7B;">__m128i</span> <span style="color: #dcaeea;">t4</span> = _mm_madd_epi16<span style="color: #51afef;">(</span>t3, mul_1_10000<span style="color: #51afef;">)</span>;
</pre>
</div>
<pre class="example" id="orgb702b62">
Values:        1234     5678
Multipliers:  10000        1
                  |        |
Results:   12340000     5678
                   \   /
Sum:           12345678    (final 32-bit result)

Instruction: _mm_madd_epi16 (PMADDWD again)
</pre>
</li>
<li><a id="7-3-4-2-6"></a>Summary: Why This is Fast  总结：为什么这么快<br />
<ol>
<li>Parallel Processing:        并行处理：
<ul>
<li>Processes multiple digits simultaneously         同时处理多个数字</li>
<li>Uses CPU&rsquo;s SIMD capabilities efficiently         高效利用 CPU 的 SIMD 功能</li>

</ul></li>
<li>Instruction Count:        指令数量：
<ul>
<li>Traditional: ~8 loads + ~8 multiplies + ~7 adds         传统方法：大约 8 次加载、8 次乘法、7 次加法</li>
<li>SIMD: ~7 total instructions         SIMD 方法：总共约 7 条指令</li>

</ul></li>
<li>Latency Analysis on Haswell:        在 Haswell 上的延迟分析：
<ul>
<li>PSUBB (subtract): 1 cycle         PSUBB（减法）：1 个周期</li>
<li>PMADDUBSW (multiply-add bytes): 5 cycles         PMADDUBSW（乘加字节）：5 个周期</li>
<li>PMADDWD (multiply-add words): 5 cycles         PMADDWD（乘加字）：5 个周期</li>
<li>PACKUSDW (pack): 1 cycle         PACKUSDW（打包）：1 个周期</li>
<li>Total latency: ~17 cycles         总延迟：约 17 个周期</li>

</ul></li>

</ol>
</li>
</ol>
</li>
</ol>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Actual c++ code implementation and optimization tricks in the code base  代码库中的实际 C++ 实现及优化技巧</h2>
<div class="outline-text-2" id="text-8">
</div>
</section>
<section id="slide-8-1">
<h3 id="8-1"><span class="section-number-3">8.1.</span> SIMD8 zero cost &ldquo;abstraction&rdquo;  SIMD8 零成本“抽象”</h3>
<div class="org-src-container">

<pre class="src src-text">                          +---------------------+
                          |    base&lt;Child&gt;      |
                          +---------------------+
                                    &#9474;
                                    &#9474;
                     +--------------&#9524;--------------+
                     |                             |
              (for T &#8800; bool)                   (for bool)
                     |                             |
              +------&#9660;------+                +------&#9660;------+
              |   base8&lt;T&gt;  |                | base8&lt;bool&gt; |
              +-------------+                +-------------+
                     &#9474;                             &#9474;
                     &#9474;                             &#9474;
            +--------&#9660;--------+                    &#9474;
            | base8_numeric&lt;T&gt;|                    &#9474;
            +-----------------+                    &#9474;
                     &#9474;                       +-----&#9660;-----+
           +---------&#9524;---------+             |simd8&lt;bool&gt;|
           |                   |             +-----------+
           |                   |
   +-------&#9660;-------+   +-------&#9660;-------+
   | simd8&lt;int8_t&gt; |   | simd8&lt;uint8_t&gt;|
   +---------------+   +---------------+

base&lt;simd8&lt;uint8_t&gt;&gt;     // Base template
    &#8593;
base8&lt;uint8_t&gt;          // Adds common SIMD operations
    &#8593;
base8_numeric&lt;uint8_t&gt;  // Adds numeric operations
    &#8593;
simd8&lt;uint8_t&gt;         // Final implementation
</pre>
</div>
</section>
<section id="slide-8-1-1">
<h4 id="8-1-1"><span class="section-number-4">8.1.1.</span> Quality of life abstractions  提升使用体验的抽象</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;&gt;</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span>: <span style="color: #ECBE7B;">base8_numeric</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Saturated math</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">saturating_add</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_adds_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">saturating_sub</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_subs_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Order-specific operations</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">max_val</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_max_epu8<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">min_val</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> _mm256_min_epu8<span style="color: #98be65;">(</span>other, *<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Same as &gt;, but only guarantees true is nonzero (&lt; guarantees true = -1)</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">gt_bits</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;saturating_sub<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Same as &lt;, but only guarantees true is nonzero (&lt; guarantees true = -1)</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #c678dd;">lt_bits</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.saturating_sub<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&lt;=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.max_val<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span> == other; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&gt;=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> other.min_val<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span><span style="color: #98be65;">)</span> == other; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&gt;</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;gt_bits<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>.any_bits_set<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #c678dd;">&gt;</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&lt;</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">simd8</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #98be65;">&gt;</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef;">this</span>-&gt;lt_bits<span style="color: #98be65;">(</span>other<span style="color: #98be65;">)</span>.any_bits_set<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
</section>
<section id="slide-8-1-2">
<h4 id="8-1-2"><span class="section-number-4">8.1.2.</span> Quality of life abstractions  提升使用体验的抽象</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Bit-specific operations</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">bits_not_set</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> *<span style="color: #51afef;">this</span> == uint8_t<span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">bits_not_set</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span> &amp; bits<span style="color: #c678dd;">)</span>.bits_not_set<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">any_bits_set</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> ~<span style="color: #51afef;">this</span>-&gt;bits_not_set<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">bool</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">any_bits_set</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> ~<span style="color: #51afef;">this</span>-&gt;bits_not_set<span style="color: #c678dd;">(</span>bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">is_ascii</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_movemask_epi8<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span><span style="color: #c678dd;">)</span> == <span style="color: #da8548; font-weight: bold;">0</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">bits_not_set_anywhere</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_testz_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, *<span style="color: #51afef;">this</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">any_bits_set_anywhere</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef; font-weight: bold;">!</span>bits_not_set_anywhere<span style="color: #c678dd;">()</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">bits_not_set_anywhere</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_testz_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">any_bits_set_anywhere</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">simd8</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">bits</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> <span style="color: #51afef; font-weight: bold;">!</span>bits_not_set_anywhere<span style="color: #c678dd;">(</span>bits<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">shr</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> simd8<span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;(</span>_mm256_srli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> &amp; uint8_t<span style="color: #c678dd;">(</span><span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">FF</span><span style="color: #51afef;">u</span> &gt;&gt; N<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">shl</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> simd8<span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">uint8_t</span><span style="color: #c678dd;">&gt;(</span>_mm256_slli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> &amp; uint8_t<span style="color: #c678dd;">(</span><span style="color: #51afef;">0x</span><span style="color: #a9a1e1;">FF</span><span style="color: #51afef;">u</span> &lt;&lt; N<span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get one of the bits and make a bitmask out of it.</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">e.g. value.get_bit&lt;7&gt;() gets the high bit</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">N</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">get_bit</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span> <span style="color: #51afef;">return</span> _mm256_movemask_epi8<span style="color: #c678dd;">(</span>_mm256_slli_epi16<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, <span style="color: #da8548; font-weight: bold;">7</span>-N<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>; <span style="color: #51afef;">}</span>
</pre>
</div>
<ol class="org-ol">
<li><a id="8-1-2-1"></a>Template Metaprogramming &amp; CRTP vs. Virtual Functions (Dynamic Binding)  模板元编程 &amp; CRTP 与虚函数（动态绑定）的比较<br />
<ul>
<li><b><b>Compile-Time Polymorphism with Templates/CRTP:</b></b>         使用模板/CRTP 的编译时多态：
<ul>
<li><b><b>Zero-Cost Abstraction:</b></b> The CRTP pattern lets the compiler resolve function calls at compile time.         零成本抽象：CRTP 模式使编译器在编译时解析函数调用。
<ul>
<li><p>
<b>Example from simdjson:</b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">Child</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded operator (inline, no vtable overhead)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> simdjson_inline <span style="color: #ECBE7B;">Child</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #51afef;">const</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> _mm256_or_si256<span style="color: #98be65;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">}</span>;
</pre>
</div></li>

</ul></li>
<li><b><b>Inlining &amp; Optimization:</b></b> The compiler can inline these functions, reducing function call overhead.         内联与优化：编译器可以将这些函数内联，从而减少调用开销。</li>
<li><b><b>No Runtime Indirection:</b></b> Since the dispatch is resolved at compile time, there&rsquo;s no need for a vtable lookup.         无运行时间接调用：因为调度在编译时解决，无需虚表查找。</li>
<li><b><b>Drawback:</b></b> Code bloat can occur due to multiple template instantiations, but this is usually an acceptable trade-off in performance‑critical code.         缺点：多次模板实例化可能导致代码膨胀，但在性能关键的代码中通常是可以接受的权衡.</li>

</ul></li>

</ul>
</li>
</ol>
</section>
<section id="slide-8-1-3">
<h4 id="8-1-3"><span class="section-number-4">8.1.3.</span> Dynamic Binding with Virtual Functions  使用虚函数进行动态绑定</h4>
<ul>
<li><b><b>Late Binding:</b></b> Function calls are resolved at runtime via a vtable.         后期绑定：函数调用在运行时通过虚表解析.
<ul>
<li><p>
<b>Example (the costly alternative):</b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span><span style="color: #c678dd;">()</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">virtual</span> ~<span style="color: #c678dd;">Base</span><span style="color: #c678dd;">()</span> = <span style="color: #51afef;">default</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
     
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Derived</span> : <span style="color: #ECBE7B;">Base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">foo</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">override</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">... implementation ...</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div></li>

</ul></li>
<li><b><b>Runtime Overhead:</b></b>         运行时开销:
<ul>
<li>Each call incurs an extra indirection (vtable lookup).         每次调用都需要额外一次间接调用（虚表查找）。</li>
<li>Virtual calls are generally not inlined because the exact function is only known at runtime.         虚函数调用通常不能内联，因为具体函数在运行时才确定.</li>

</ul></li>
<li><b><b>Comparable to Java Interfaces:</b></b>         类似于 Java 接口:
<ul>
<li>In Java, interface methods (or virtual methods) are dispatched at runtime. While a JIT can sometimes inline such calls when it detects hot paths, C++ does not have a JIT and relies entirely on compile‑time optimizations.         在 Java 中，接口方法（或虚函数）在运行时分派。虽然 JIT 有时会在检测到热点</li>

</ul></li>
<li><b><b>Runtime Overhead:</b></b> Each call incurs an extra indirection (vtable lookup). Virtual calls are generally not inlined because the exact function is only known at runtime.  运行时开销：每次调用都需要额外一次间接调用（虚表查找）。虚函数调用通常不能内联，因为具体函数在运行时才确定.</li>
<li><b><b>Comparable to Java Interfaces:</b></b> In Java, interface methods (or virtual methods) are dispatched at runtime. While a JIT can sometimes inline such calls when it detects hot paths, C++ does not have a JIT and relies entirely on compile‑time optimizations.  类似于 Java 接口：在 Java 中，接口方法（或虚函数）在运行时分派。虽然 JIT 有时会在检测到热点路径时内联这些调用，但 C++ 没有 JIT，完全依赖编译时优化.</li>

</ul>
</section>
<section id="slide-8-1-4">
<h4 id="8-1-4"><span class="section-number-4">8.1.4.</span> Why C++ Chooses Compile-Time Polymorphism  为什么 C++ 选择编译时多态</h4>
<ul>
<li><b><b>Performance Sensitivity:</b></b> In scenarios like high‑performance parsing (as in simdjson), every extra cycle counts.  性能敏感性：在像 simdjson 这样的高性能解析场景中，每个额外的周期都非常重要.</li>
<li><b><b>Deterministic Overhead:</b></b> With templates/CRTP, the performance characteristics are known at compile time—there’s no hidden cost of runtime dispatch.  开销可控：使用模板/CRTP，性能特性在编译时就已知——没有运行时调度的隐藏成本.</li>
<li><b><b>Contrast with Java:</b></b>  与 Java 的对比：
<ul>
<li>Java’s JIT can optimize away some of the virtual call overhead during runtime, but C++ has to resolve everything during compilation, making it essential to use techniques that yield zero‑overhead abstractions.  Java 的 JIT 可以在运行时优化掉部分虚函数调用开销，但 C++ 必须在编译时解决所有问题，因此必须采用零开销抽象技术.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-1-5">
<h4 id="8-1-5"><span class="section-number-4">8.1.5.</span> Inline Functions &amp; Compile-Time Inlining  内联函数与编译时内联</h4>
<ul>
<li><b><b>Technique:</b></b> Functions are marked with `simdjson_inline` to encourage inlining.  技巧：使用 `simdjson_inline` 标记函数以促进内联.</li>
<li><b><b>Why?</b></b> Inlining eliminates function call overhead for tiny, frequently used functions.  原因：内联消除了小型、频繁调用函数的调用开销.</li>
<li><b><b>Example from simdjson:</b></b>  simdjson 示例：</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #51afef; font-weight: bold;">#elif</span> <span style="color: #51afef; font-weight: bold;">defined</span><span style="color: #51afef;">(</span><span style="color: #a9a1e1;">__GNUC__</span><span style="color: #51afef;">)</span> &amp;&amp; <span style="color: #51afef; font-weight: bold;">!</span><span style="color: #51afef; font-weight: bold;">defined</span><span style="color: #51afef;">(</span><span style="color: #a9a1e1;">__OPTIMIZE__</span><span style="color: #51afef;">)</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">If optimizations are disabled, forcing inlining can lead to significant</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">code bloat and high compile times. Don't use simdjson_really_inline for</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unoptimized builds.</span>
<span style="color: #3dea43364a63;"> </span><span style="color: #51afef; font-weight: bold;"> #define</span> <span style="color: #dcaeea;">simdjson_inline</span> <span style="color: #51afef;">inline</span>
<span style="color: #51afef; font-weight: bold;">#else</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded bitwise OR operator</span>
simdjson_inline <span style="color: #ECBE7B;">Child</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> _mm256_or_si256<span style="color: #c678dd;">(</span>*<span style="color: #51afef;">this</span>, other<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<ul>
<li><b><b>Note:</b></b> The use of inlining on all small operations (e.g. arithmetic, bitwise operators) ensures maximum performance.  注意：对所有小操作（如算术运算、位运算）使用内联可确保最佳性能.</li>

</ul>
</section>
<section id="slide-8-2">
<h3 id="8-2"><span class="section-number-3">8.2.</span> C++ Casts in simdjson: Performance Considerations  simdjson 中 C++ 类型转换：性能考虑</h3>
<ul>
<li>In high‑performance C++ code, using the proper cast is essential for both safety and speed.  在高性能 C++ 代码中，使用合适的类型转换对于安全和速度至关重要.</li>
<li>C++ provides several cast operators:  C++ 提供了多种类型转换操作符:
<ul>
<li><b><b>static_cast</b></b>: Compile‑time conversions.  **static_cast**：编译时转换.</li>
<li><b><b>reinterpret_cast</b></b>: Low‑level, pointer and bit‑reinterpretation.  **reinterpret_cast**：底层指针及位转换.</li>
<li><b><b>const_cast</b></b>: Remove constness.  **const_cast**：去除 const 属性.</li>
<li><b><b>dynamic_cast</b></b>: Runtime-checked casts (with RTTI).  **dynamic_cast**：运行时检查转换（带 RTTI）.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-2-1">
<h4 id="8-2-1"><span class="section-number-4">8.2.1.</span> static_cast for CRTP Efficiency  CRTP 高效的 static_cast</h4>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">template</span><span style="color: #51afef;">&lt;</span><span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">Child</span><span style="color: #51afef;">&gt;</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">base</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">__m256i</span> <span style="color: #dcaeea;">value</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Overloaded compound assignment using CRTP</span>
<span style="color: #3dea43364a63;"> </span>   simdjson_inline <span style="color: #ECBE7B;">Child</span>&amp; <span style="color: #51afef;">operator</span><span style="color: #c678dd;">|=</span><span style="color: #c678dd;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Child</span> <span style="color: #dcaeea;">other</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">this_cast</span> = <span style="color: #51afef;">static_cast</span><span style="color: #98be65;">&lt;</span><span style="color: #ECBE7B;">Child</span>*<span style="color: #98be65;">&gt;(</span><span style="color: #51afef;">this</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> *this_cast = *this_cast | other;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> *this_cast;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #c678dd;">}</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>;
</pre>
</div>
<ul>
<li><b><b>Notes:</b></b>
<ul>
<li>The `static_cast&lt;Child*&gt;(this)` converts the base class pointer to the derived type.  `static_cast&lt;Child*&gt;(this)` 将基类指针转换为派生类指针.</li>
<li>This conversion happens entirely at compile time, incurring no runtime cost.  该转换完全在编译时完成，不会产生运行时开销.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-2-2">
<h4 id="8-2-2"><span class="section-number-4">8.2.2.</span> reinterpret_cast for SIMD Memory Operations  SIMD 内存操作中的 reinterpret_cast</h4>
<ul>
<li><b><b>Purpose:</b></b> Reinterpret raw memory (such as an array of bytes) as SIMD register types.  目的：将原始内存（如字节数组）重新解释为 SIMD 寄存器类型.</li>
<li><b><b>Why?:</b></b> When working with intrinsics (e.g. AVX2), you need to treat data as a special type (like `__m256i`), and reinterpret_cast does this with no extra overhead.  原因：在使用内置函数（例如 AVX2）时，需要将数据视为特定类型（如 `__m256i`），而 reinterpret_cast 可以在无额外开销的情况下完成此操作.</li>
<li><b><b>Examples from simdjson:</b></b>  simdjson 示例：
<ul>
<li><p>
<b><b>Loading Data:</b></b>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">static</span> simdjson_inline <span style="color: #ECBE7B;">simd8</span><span style="color: #51afef;">&lt;</span><span style="color: #ECBE7B;">T</span><span style="color: #51afef;">&gt;</span> <span style="color: #c678dd;">load</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">T</span> <span style="color: #dcaeea;">values</span><span style="color: #c678dd;">[</span><span style="color: #da8548; font-weight: bold;">32</span><span style="color: #c678dd;">]</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> _mm256_loadu_si256<span style="color: #c678dd;">(</span><span style="color: #51afef;">reinterpret_cast</span><span style="color: #98be65;">&lt;</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">__m256i</span> *<span style="color: #98be65;">&gt;(</span>values<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">}</span>
</pre>
</div></li>

</ul></li>
<li><b><b>Notes:</b></b>
<ul>
<li>These reinterpret_casts allow the compiler to generate efficient SIMD load/store instructions.  这些 reinterpret_cast 使编译器能生成高效的 SIMD 加载/存储指令.</li>
<li>They incur no runtime penalty as they are resolved during compilation.  它们在编译时解析，不产生运行时开销.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-2-3">
<h4 id="8-2-3"><span class="section-number-4">8.2.3.</span> Why Not dynamic_cast or const_cast?  为什么不使用 dynamic_cast 或 const_cast？</h4>
<ul>
<li><b><b>dynamic_cast:</b></b>
<ul>
<li>Performs runtime type checking and incurs additional overhead.  执行运行时类型检查，会产生额外开销.</li>
<li>Not used in performance-critical paths like simdjson.  在 simdjson 这类性能关键路径中不使用.</li>

</ul></li>
<li><b><b>const_cast:</b></b>
<ul>
<li>Removes constness, but simdjson is designed with const correctness in mind.  移除 const 属性，但 simdjson 设计时已考虑 const 正确性.</li>
<li>There’s no need to remove constness in this low‑level, performance‑sensitive code.  在这种底层、性能敏感的代码中无需移除 const 属性.</li>

</ul></li>
<li><b><b>Summary:</b></b>
<ul>
<li>simdjson relies on <b><b>static_cast</b></b> and <b><b>reinterpret_cast</b></b> (plus implicit conversion operators) because they guarantee zero or minimal runtime overhead.  simdjson 依赖于 <b><b>static_cast</b></b> 和 **reinterpret_cast**（以及隐式转换运算符），因为它们能保证零或极低的运行时开销.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-2-4">
<h4 id="8-2-4"><span class="section-number-4">8.2.4.</span> Summary of Casts in simdjson  simdjson 中类型转换的总结</h4>
<ul>
<li><b><b>static_cast:</b></b>
<ul>
<li>Used for compile‑time conversions (e.g. CRTP base-to-derived pointer conversion).  用于编译时转换（例如 CRTP 中基类指针到派生类指针的转换）.</li>
<li>Zero‑cost and type‑safe.  零开销且类型安全.</li>

</ul></li>
<li><b><b>reinterpret_cast:</b></b>
<ul>
<li>Used for pointer re‑interpretation (e.g. converting a byte array to a SIMD register pointer).  用于指针重解释（例如将字节数组转换为 SIMD 寄存器指针）.</li>
<li>Necessary for interfacing with low‑level intrinsics.  对于与底层内置函数接口至关重要.</li>

</ul></li>
<li><b><b>Avoided Casts:</b></b>
<ul>
<li><b><b>dynamic_cast</b></b> and <b><b>const_cast</b></b> are not used in performance-critical sections to prevent unnecessary runtime overhead.  在性能关键部分不使用 <b><b>dynamic_cast</b></b> 和 **const_cast**，以避免不必要的运行时开销.</li>

</ul></li>

</ul>
</section>
<section id="slide-8-3">
<h3 id="8-3"><span class="section-number-3">8.3.</span> Why Error Codes Outperform Exceptions  为什么错误码优于异常处理</h3>
<ul>
<li>Zero-cost error handling: No stack unwinding or EH tables  零成本错误处理：无需栈展开或异常处理表</li>
<li>Better compiler optimizations: Linear control flow  更佳的编译器优化：线性控制流</li>
<li>Predictable branch patterns: CPU pipelining friendly  可预测的分支模式：有利于 CPU 流水线</li>
<li>Smaller code size: No exception handling metadata  更小的代码体积：无异常处理元数据</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++">simdjson_warn_unused <span style="color: #ECBE7B;">error_code</span> <span style="color: #c678dd;">minify</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">uint8_t</span> *<span style="color: #dcaeea;">buf</span>, <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">len</span>, <span style="color: #ECBE7B;">uint8_t</span> *<span style="color: #dcaeea;">dst</span>, <span style="color: #ECBE7B;">size_t</span> &amp;<span style="color: #dcaeea;">dst_len</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">const</span> <span style="color: #51afef;">noexcept</span> <span style="color: #51afef;">final</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">return</span> set_best<span style="color: #c678dd;">()</span>-&gt;minify<span style="color: #c678dd;">(</span>buf, len, dst, dst_len<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-8-3-1">
<h4 id="8-3-1"><span class="section-number-4">8.3.1.</span> Assembly Comparison: Error Code vs Exception  汇编比较：错误码 vs 异常</h4>
<div class="outline-text-4" id="text-8-3-1">
</div>
<ol class="org-ol">
<li><a id="8-3-1-1"></a>Error Code Path (simdjson style)  错误码路径（simdjson 风格）<br />
<div class="org-src-container">

<pre class="src src-asm"><span style="color: #c678dd;">check_ascii</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">vptest</span> <span style="color: #dcaeea;">%ymm0</span>, <span style="color: #dcaeea;">%ymm1</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">jne</span> .error        <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Single conditional branch</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... normal path ...</span>
 
<span style="color: #c678dd;">.error</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">mov</span> eax, <span style="color: #da8548; font-weight: bold;">1</span>        <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Set error code</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">ret</span>
</pre>
</div>
</li>
<li><a id="8-3-1-2"></a>Exception Path  异常路径<br />
<div class="org-src-container">

<pre class="src src-asm"><span style="color: #c678dd;">check_ascii</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">vptest</span> <span style="color: #dcaeea;">%ymm0</span>, <span style="color: #dcaeea;">%ymm1</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">jne</span> .exception
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... normal path ...</span>
 
<span style="color: #c678dd;">.exception</span>:
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">call</span> __cxa_allocate_exception  <span style="color: #5B6268;">; </span><span style="color: #5B6268;">Heavy EH machinery</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #5B6268;">; </span><span style="color: #5B6268;">... stack unwinding setup ...</span>
</pre>
</div>
</li>
</ol>
</section>
<section id="slide-8-3-2">
<h4 id="8-3-2"><span class="section-number-4">8.3.2.</span> Key Performance Factors  关键性能因素</h4>
<ol>
<li><b><b>No EH Table Overhead</b></b>  无异常处理表开销
<ul>
<li>Exception handling requires RTTI and stack unwinding tables  异常处理需要 RTTI 和栈展开表</li>
<li>Increases binary size by ~10-15% in our benchmarks  在我们的基准测试中，二进制文件大小增加约 10-15%</li>

</ul></li>
<li><b><b>CPU Branch Prediction</b></b>  CPU 分支预测
<ul>
<li>Error codes use simple conditional branches  错误码使用简单条件分支
<ul>
<li>Exceptions create unpredictable control flow  而异常则会导致不可预测的控制流</li>

</ul></li>

</ul></li>
<li><b><b>Inlining Friendly</b></b>  有利于内联
<ul>
<li>Error return paths don&rsquo;t inhibit function inlining  错误返回路径不会阻碍函数内联</li>
<li>Critical for SIMD optimizations:  对 SIMD 优化至关重要:</li>

</ul></li>

</ol>
</section>
<section id="slide-8-4">
<h3 id="8-4"><span class="section-number-3">8.4.</span> Memory Alignment &amp; Padding  内存对齐与填充</h3>
<ul>
<li>Correct memory alignment (and extra padding) is crucial for SIMD operations; unaligned accesses can severely hurt performance.  正确的内存对齐（及额外填充）对 SIMD 操作至关重要；未对齐的访问会严重影响性能.</li>
<li>simdjson uses types such as padded_string and padded_string_view to guarantee ample padding.  simdjson 使用 padded_string 和 padded_string_view 等类型来确保足够的填充.</li>
<li>Example from the padded string view helper:  来自 padded string view 辅助函数的示例:</li>

</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a9a1e1;">simdjson</span>::<span style="color: #ECBE7B;">padded_string_view</span> <span style="color: #c678dd;">get_padded_string_view</span><span style="color: #51afef;">(</span><span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">buf</span>, <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">len</span>,
<span style="color: #3dea43364a63;"> </span>                                                  <span style="color: #a9a1e1;">simdjson</span>::<span style="color: #ECBE7B;">padded_string</span> &amp;<span style="color: #dcaeea;">jsonbuffer</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span> <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span>need_allocation<span style="color: #98be65;">(</span>buf, len<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unlikely case</span>
<span style="color: #3dea43364a63;"> </span>   jsonbuffer = <span style="color: #a9a1e1;">simdjson</span>::padded_string<span style="color: #98be65;">(</span>buf, len<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> jsonbuffer;
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span> <span style="color: #51afef;">else</span> <span style="color: #c678dd;">{</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">no allocation needed (most common)</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">simdjson</span>::padded_string_view<span style="color: #98be65;">(</span>buf, len, len + <span style="color: #a9a1e1;">simdjson</span>::<span style="color: #a9a1e1;">SIMDJSON_PADDING</span><span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span> <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</section>
<section id="slide-8-5">
<h3 id="8-5"><span class="section-number-3">8.5.</span> Loop Unrolling and Vectorized Processing  循环展开与向量化处理</h3>
<ul>
<li><b><b>Key idea:</b></b> Unroll loops to manually do more things in one loop  关键思想：展开循环，在一次循环中执行更多操作</li>

</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">extract_set_bits_optimized</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">uint64_t</span> <span style="color: #dcaeea;">bitset</span>, <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">output</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Get total number of set bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span> <span style="color: #dcaeea;">count</span> = __builtin_popcountll<span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #ECBE7B;">uint32_t</span>* <span style="color: #dcaeea;">next_base</span> = output + count;
 
<span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Process 8 bits at a time unconditionally</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>bitset<span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Extract next 8 set bit positions, even if we don't have 8 bits</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   *output++ = __builtin_ctzll<span style="color: #98be65;">(</span>bitset<span style="color: #98be65;">)</span>;
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>   bitset &amp;= <span style="color: #98be65;">(</span>bitset - <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #98be65;">)</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Clear lowest set bit (blsr instruction)</span>
</pre>
</div>
</section>
<section id="slide-8-6">
<h3 id="8-6"><span class="section-number-3">8.6.</span> Runtime CPU Dispatching  运行时 CPU 分派</h3>
<ul>
<li>Instead of compiling separate binaries for different architectures, simdjson selects the best implementation at runtime.  simdjson 在运行时选择最佳实现，而不是为不同架构编译单独的二进制文件.</li>
<li>By using functions like get_active_implementation(), it dynamically chooses the fastest SIMD path available.  通过使用 get_active_implementation() 等函数，它动态选择最快的 SIMD 路径.</li>
<li>Example:  示例:</li>

</ul>
<div class="org-src-container">

<pre class="src src-cpp">cout &lt;&lt; <span style="color: #98be65;">"Active implementation: "</span>
<span style="color: #3dea43364a63;"> </span>   <span style="color: #3dea43364a63;"> </span>&lt;&lt; <span style="color: #a9a1e1;">simdjson</span>::get_active_implementation<span style="color: #51afef;">()</span>-&gt;name<span style="color: #51afef;">()</span> &lt;&lt; endl;
</pre>
</div>
</section>
<section id="slide-8-7">
<h3 id="8-7"><span class="section-number-3">8.7.</span> Avoiding Unnecessary Allocations  避免不必要的内存分配</h3>
<ul>
<li>Reusing pre-allocated buffers improves cache locality and reduces repeated allocation overhead.  重用预分配缓冲区可改善缓存局部性并减少重复分配的开销.</li>
<li>simdjson’s parser retains internal buffers between parses, so the expensive memory allocation is done only once.  simdjson 的解析器在每次解析之间保留内部缓冲区，因此昂贵的内存分配只进行一次.</li>

</ul>
</section>
<section id="slide-8-8">
<h3 id="8-8"><span class="section-number-3">8.8.</span> Compiler Directives &amp; Special Build Flags  编译器指令与特殊构建标志</h3>
<ul>
<li>Compiler flags (for instance, -O3 or -march=native) and specific macros are key to unlocking peak performance.  编译器标志（例如 -O3 或 -march=native）及特定宏是发挥最高性能的关键.</li>

</ul>
</section>
<section id="slide-8-9">
<h3 id="8-9"><span class="section-number-3">8.9.</span> C++ optimizations summary  C++ 优化总结</h3>
<ul>
<li>Zero cost abstractions  零成本抽象</li>
<li>inline functions and casting  内联函数与类型转换</li>
<li>Error code over exceptions  使用错误码而非异常</li>
<li>memory and loop optimizations  内存与循环优化</li>

</ul>
</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Thank you  谢谢大家</h2>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/search/search.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'slide',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
